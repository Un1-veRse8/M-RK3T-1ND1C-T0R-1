//  TASC Issue: June 2025
//     Article: The Cybernetic Oscillator For More Flexibility
//              Making A Better Oscillator
//  Article By: John F. Ehlers
//    Language: TradingView's Pine ScriptÂ® v6
// Provided By: PineCoders, for tradingview.com

//@version=6
TITLE   = "TASC 2025.06 Cybernetic Oscillator"
S_TITLE = "CO"
indicator(TITLE, S_TITLE)


//#region --- Enum and inputs ---

// @enum An enumeration of possible display styles.
enum style 
    Trend
    Threshold

// @variable The source series to process. 
float srcInput = input.source(close, "Source series:")
// @variable The highpass filter critical period. 
int hpInput = input.int(30, "Highpass period:", 3)
// @variable The lowpass filter critical period. 
int lpInput = input.int(20, "Lowpass period:", 3)
// @variable The number of bars in the RMS calculation.
int rmsInput = input.int(100, "RMS length:", 1)

// @variable A named value for the display style. 
style styleInput = input.enum(style.Trend, "Display style:")
// @variable The absolute threshold for the "Threshold" display style.
float thInput = input.float(1, "Threshold:", minval = 0, step = 0.1)

// Raise a runtime error if `hpInput` is less than `lpInput`.
if hpInput < lpInput
    runtime.error("The highpass period cannot be less than the lowpass period.")
//#endregion


//#region --- Functions ---

// @function         Calculates coefficients for the `hp()` and `ss()` functions.
// @param period     The critical period of the filter.
// @param isHp       If `true`, the coefficients are for a highpass filter. Otherwise, 
//                   they are for a lowpass filter. 
// @returns          A tuple containing the highpass or lowpass filter coefficients. 
coefs(simple int period, simple bool isHp) =>
    var float a0 = 1.414 * math.pi / period
    var float a1 = math.exp(-a0)
    var float c2 = 2.0 * a1 * math.cos(a0)
    var float c3 = -a1 * a1
    var float c1 = isHp ? (1.0 + c2 - c3) * 0.25 : 1.0 - c2 - c3
    [c1, c2, c3]


// @function         Calculates a second-order highpass filter.
// @param source     The series of values to process. 
// @param period     The length of the filter's critical period.
// @returns          The filtered `source` value. 
hp(float source, simple int period) =>
    var float result = 0.0
    if bar_index >= 4
        [c1, c2, c3] = coefs(period, true)
        result := c1 * (source - 2.0 * source[1] + source[2]) + 
                  c2 * nz(result[1]) + 
                  c3 * nz(result[2])
    result


// @function         Calculates a Super Smoother filter (second-order lowpass).
// @param source     The series of values to process.
// @param period     The length of the filter's critical period.
// @returns          The filtered `source` value. 
ss(float source, simple int period) =>
    var float result = source
    if bar_index >= 4
        [c1, c2, c3] = coefs(period, false)
        result := c1 * 0.5 * (source + source[1]) + 
                  c2 * nz(result[1]) +
                  c3 * nz(result[2])
    result


// @function         Calculates the root mean square (RMS) of a series.
// @param source     The series of values to process.
// @param length     The number of bars in the calculation.
// @returns          The RMS of the `source` values over `length` bars.
rms(float source, simple int length) =>
    math.sqrt(ta.sma(source * source, length))


// @function         Calculates the Cybernetic Oscillator.
// @param source     The series of values to process. 
// @param hpPeriod   The highpass filter critical period.
// @param lpPeriod   The lowpass filter critical period.
// @param rmsInput   The number of bars in the RMS calculation. 
// @returns          The Cybernetic Oscillator of `source` with specified settings.
co(float source, simple int hpPeriod, simple int lpPeriod, simple int rmsInput) =>
    var float result = 0.0
    float hp  = hp(source, hpPeriod)
    float lp  = ss(hp, lpPeriod)
    float rms = rms(lp, rmsInput)
    if rms != 0.0
        result := lp / rms
    result
//#endregion


//#region --- Calculations and display ---

// @variable Is `true` if the selected style is `style.Threshold`; `false` otherwise. 
bool isThresh = styleInput == style.Threshold 

// @variable The Cybernetic Oscillator of the `srcInput` series with specified settings. 
float osc = co(srcInput, hpInput, lpInput, rmsInput)

// Plot the `osc` value with a color based on the chosen display style. 
p0 = plot(
     osc, "Cybernetic Oscillator", 
     isThresh ? #aa9b9b : osc > 0.0 ? #4caf4f : #af4e4c, 2
 )
// Plot the upper and lower thresholds. 
pu = plot(isThresh ?  thInput : na, "Upper threshold", #b2b5be80)
pl = plot(isThresh ? -thInput : na, "Lower threshold", #b2b5be80)
// Fill the space between the plots based on the `osc` and `thInput` values. 
fill(p0, pu, isThresh and osc >   thInput ? #af4e4c93 : na, title = "Upper fill")
fill(p0, pl, isThresh and osc < - thInput ? #4caf4f93 : na, title = "Lower fill")

// Create a horizontal line at 0.
hline(0)
//#endregion