// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © RWCS_LTD

//@version=6
// @description A utility library for common statistical indicators and ratios used in technical analysis.
// Includes Z-Score, correlation, PLF, SRI, Sharpe, Sortino, Omega ratios, and normalization tools.
library("StatMetrics")

//@function Calculates the Z-score of a series
//@param src The input price or series (e.g., close)
//@param len The lookback period for mean and standard deviation
//@returns Z-score: number of standard deviations the input is from the mean
export zscore(series float src, simple int len) =>
    mean = ta.sma(src, len)
    std = ta.stdev(src, len)
    std := std == 0 ? 1e-10 : std
    (src - mean) / std

//@function Computes Pearson correlation coefficient between two series
//@param x First series
//@param y Second series
//@param len Lookback period
//@returns Correlation coefficient between -1 and 1
export corr(series float x, series float y, simple int len) =>
    ta.correlation(x, y, len)

//@function Calculates the Price Lag Factor (PLF) as the difference between long and short Z-scores, normalized and smoothed
//@param src Source series (e.g., close)
//@param longLen Long Z-score period
//@param shortLen Short Z-score period
//@param smoothLen Hull MA smoothing length
//@returns Smoothed and normalized PLF oscillator
export plf(series float src, simple int longLen, simple int shortLen, simple int smoothLen) =>
    longZ = zscore(src, longLen)
    shortZ = zscore(src, shortLen)
    raw = longZ - shortZ
    std = ta.stdev(raw, longLen)
    std := std == 0 ? 1e-10 : std
    normalized = raw / std
    ta.hma(normalized, smoothLen)

//@function Computes the Statistical Reliability Index (SRI) based on trend persistence
//@param signal A price or signal series (e.g., smoothed PLF)
//@param len Lookback period for smoothing and deviation
//@returns Normalized trend reliability score
export sri(series float signal, simple int len) =>
    trend = signal > signal[1] ? 1 : signal < signal[1] ? -1 : 0
    sri_raw = ta.ema(trend, len)
    std = ta.stdev(sri_raw, len)
    std := std == 0 ? 1e-10 : std
    sri_raw / std

//@function Calculates the Sharpe Ratio over a period
//@param src Price series (e.g., close)
//@param len Lookback period
//@returns Sharpe ratio value
export sharpe(series float src, simple int len) =>
    returns = src / src[1] - 1
    mean = ta.sma(returns, len)
    std = ta.stdev(returns, len)
    std := std == 0 ? 1e-10 : std
    mean / std

//@function Calculates the Sortino Ratio over a period, using only downside volatility
//@param src Price series
//@param len Lookback period
//@returns Sortino ratio value
export sortino(series float src, simple int len) =>
    returns = src / src[1] - 1
    negative_returns = returns <= 0 ? returns : na
    downside_std = ta.stdev(negative_returns, len)
    downside_std := downside_std == 0 ? 1e-10 : downside_std
    mean = ta.sma(returns, len)
    mean / downside_std

//@function Calculates the Omega Ratio as the ratio of upside to downside return area
//@param src Price series
//@param len Lookback period
//@returns Omega ratio value
export omega(series float src, simple int len) =>
    returns = src / src[1] - 1
    pos = returns > 0 ? returns : 0
    neg = returns < 0 ? -returns : 0
    sumPos = math.sum(pos, len)
    sumNeg = math.sum(neg, len)
    sumNeg := sumNeg == 0 ? 1e-10 : sumNeg
    sumPos / sumNeg

//@function Calculates beta coefficient of asset vs benchmark using rolling covariance
//@param asset Series of the asset (e.g., close)
//@param benchmark Series of the benchmark (e.g., SPX close)
//@param len Lookback window
//@returns Beta value (slope of linear regression)
export beta(series float asset, series float benchmark, simple int len) =>
    mean_asset = ta.sma(asset, len)
    mean_bench = ta.sma(benchmark, len)
    cov = ta.sma(asset * benchmark, len) - (mean_asset * mean_bench)
    var_bench = ta.variance(benchmark, len)
    var_bench := var_bench == 0 ? 1e-10 : var_bench
    cov / var_bench

//@function Calculates rolling alpha of an asset relative to a benchmark
//@param asset Series of the asset (e.g., close)
//@param benchmark Series of the benchmark (e.g., SPX close)
//@param len Lookback window
//@returns Alpha value (excess return not explained by Beta exposure)
export alpha(series float asset, series float benchmark, simple int len) =>
    // Calculate returns
    ret_asset = asset / asset[1] - 1
    ret_benchmark = benchmark / benchmark[1] - 1

    // Rolling means
    mean_asset = ta.sma(ret_asset, len)
    mean_benchmark = ta.sma(ret_benchmark, len)

    // Covariance and variance (Beta)
    cov = ta.sma(ret_asset * ret_benchmark, len) - (mean_asset * mean_benchmark)
    var_benchmark = ta.variance(ret_benchmark, len)
    var_benchmark := var_benchmark == 0 ? 1e-10 : var_benchmark
    beta = cov / var_benchmark

    // Expected return from benchmark exposure
    expected_return = beta * mean_benchmark

    // Alpha = actual return - expected return
    alpha = mean_asset - expected_return
    alpha

//@function Computes skewness of a return series
//@param x Input series (e.g., returns)
//@param len Lookback period
//@returns Skewness value
export skew(series float x, simple int len) =>
    mean = ta.sma(x, len)
    std = ta.stdev(x, len)
    std := std == 0 ? 1e-10 : std
    sum3 = 0.0
    for i = 0 to len - 1
        sum3 += math.pow((x[i] - mean) / std, 3)
    sum3 / len

//@function Computes kurtosis of a return series
//@param x Input series (e.g., returns)
//@param len Lookback period
//@returns Kurtosis value
export kurtosis(series float x, simple int len) =>
    mean = ta.sma(x, len)
    std = ta.stdev(x, len)
    std := std == 0 ? 1e-10 : std
    sum4 = 0.0
    for i = 0 to len - 1
        sum4 += math.pow((x[i] - mean) / std, 4)
    sum4 / len

//@function Calculates Coefficient of Variation
//@param x Input series (e.g., returns or prices)
//@param len Lookback period
//@returns CV value
export cv(series float x, simple int len) =>
    mean = ta.sma(x, len)
    std = ta.stdev(x, len)
    mean := mean == 0 ? 1e-10 : mean
    std / mean

//@function Calculates autocorrelation with 1-lag
//@param x Series to test
//@param len Lookback window
//@returns Autocorrelation at lag 1
export autocorr(series float x, simple int len) =>
    ta.correlation(x, x[1], len)

//@function Calculates rolling standard error of a series
//@param x Input series
//@param len Lookback window
//@returns Standard error (std dev / sqrt(n))
export stderr(series float x, simple int len) =>
    std = ta.stdev(x, len)
    std / math.sqrt(len)

//@function Calculates the Information Ratio
//@param asset Asset price series
//@param benchmark Benchmark price series
//@param len Lookback period
//@returns Information ratio (alpha / tracking error)
export info_ratio(series float asset, series float benchmark, simple int len) =>
    ret_asset = asset / asset[1] - 1
    ret_benchmark = benchmark / benchmark[1] - 1
    excess = ret_asset - ret_benchmark
    mean_excess = ta.sma(excess, len)
    std_excess = ta.stdev(excess, len)
    std_excess := std_excess == 0 ? 1e-10 : std_excess
    mean_excess / std_excess

//@function Measures deviation from benchmark (Tracking Error)
//@param asset Asset return series
//@param benchmark Benchmark return series
//@param len Lookback window
//@returns Tracking error value
export tracking_error(series float asset, series float benchmark, simple int len) =>
    ret_asset = asset / asset[1] - 1
    ret_benchmark = benchmark / benchmark[1] - 1
    diff = ret_asset - ret_benchmark
    ta.stdev(diff, len)

//@function Computes maximum drawdown over a rolling window
//@param x Price series
//@param len Lookback window
//@returns Rolling max drawdown percentage (as a negative value)
export max_drawdown(series float x, simple int len) =>
    highestClose = ta.highest(x, len)
    drawdown = (x - highestClose) / highestClose
    ta.lowest(drawdown, len)

//@function Converts Z-score into a 3-level signal
//@param z Z-score series
//@param ob Overbought threshold
//@param os Oversold threshold
//@returns -1, 0, or 1 depending on signal state
export zscore_signal(series float z, float ob, float os) =>
    z > ob ? -1 : z < os ? 1 : 0

//@function Calculates rolling R-squared (coefficient of determination)
//@param x Asset returns
//@param y Benchmark returns
//@param len Lookback window
//@returns R-squared value (0 to 1)
export r_squared(series float x, series float y, simple int len) =>
    corr = ta.correlation(x, y, len)
    corr * corr

//@function Approximates Shannon entropy using log returns
//@param x Price series
//@param len Lookback period
//@returns Approximate entropy
export entropy(series float x, simple int len) =>
    logret = math.log(x / x[1])
    mean = ta.sma(logret, len)
    std = ta.stdev(logret, len)
    -1 * mean * math.log(std + 1e-10)

//@function Detects Z-score reversals to the mean
//@param z Z-score series
//@returns +1 on upward reversal, -1 on downward
export zreversal(series float z) =>
	cross = ta.crossover(z, 0)
    cross ? 1 : cross ? -1 : 0

//@function Calculates relative momentum strength
//@param x Price series
//@param len Lookback window
//@returns Proportion of lookback where current price is higher
export momentum_rank(series float x, simple int len) =>
    count = 0.0
    for i = 1 to len
        count += x > x[i] ? 1 : 0
    count / len

//@function Normalizes a series to a 0–1 range over a period
//@param x The input series
//@param len Lookback period
//@returns Normalized value between 0 and 1
export normalize(series float x, simple int len) =>
    min = ta.lowest(x, len)
    max = ta.highest(x, len)
    bands = max - min
    bands := bands == 0 ? 1e-10 : bands
    (x - min) / bands

//@function Combines multiple normalized scores into a composite score
//@param scores An array of floats (already normalized or scaled)
//@returns Average composite score
export composite_score(float score1, float score2, float score3) =>
    (score1 + score2 + score3) / 3
