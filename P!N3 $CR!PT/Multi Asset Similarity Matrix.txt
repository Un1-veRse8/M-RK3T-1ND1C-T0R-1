// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © RicardoSantos

//@version=6
string LTITLE = 'Multi Asset Similarity Matrix'
string STITLE = 'MASM'
indicator(LTITLE, STITLE, false)


// Provides a unique and visually stunning way to analyze the similarity between various stock market indices. This script uses a range of mathematical measures to calculate the correlation between different assets, such as indices, forex, crypto, etc..
// Key Features:
// Similarity Measures: The script offers a range of similarity measures to choose from, including SSD (Sum of Squared Differences), Euclidean Distance, Manhattan Distance, Minkowski Distance, Chebyshev Distance, Correlation Coefficient, Cosine Similarity, Camberra Index, Mean Absolute Error (MAE), Mean Squared Error (MSE), Lorentzian Function, Intersection, and Penrose Shape.
// Asset Selection: Users can select the assets they want to analyze by entering a comma-separated list of tickers in the "Asset List" input field.
// Color Gradient: The script uses a color gradient to represent the similarity values between each pair of indices, with red indicating low similarity and blue indicating high similarity.
// How it Works:
// The script calculates the source method (Returns or Volume Modified Returns) for each index using the sec function.
// It then creates a matrix to hold the current values of each index over a specified window size (default is 10).
// For each pair of indices, it applies the selected similarity measure using the select function and stores the result in a separate matrix.
// The script calculates the maximum and minimum values of the similarity matrix to normalize the color gradient.
// Finally, it creates a table with the index names as rows and columns, displaying the similarity values for each pair of indices using the calculated colors.
// Visual Insights:
// The indicator provides an intuitive way to visualize the relationships between different assets. By analyzing the color-coded tables, traders can gain insights into:
// Which assets are highly correlated (blue) or uncorrelated (red)
// The strength and direction of these correlations
// Potential trading opportunities based on similarities and differences between assets
// Overall, MASM is a powerful tool for market analysis and visualization, offering a unique perspective on the relationships between various assets.
// ~llama3

//#region	Similarity functions
import RicardoSantos/SimilarityMeasures/2 as sm

enum M
	SSD
	Euclidean
	Manhattan
	Minkowski
	Chebyshev
	Correlation
	Cosine
	Camberra
	MAE
	MSE
	Lorentzian
	Intersection
	PenroseShape
	Meehl

// @function Select the method of measure.
select (M m, float[] a, float[] b) =>
	switch m
		M.SSD			=> sm.ssd(a, b)
		M.Euclidean		=> sm.euclidean(a, b)
		M.Manhattan		=> sm.manhattan(a, b)
		M.Minkowski		=> sm.minkowski(a, b)
		M.Chebyshev		=> sm.chebyshev(a, b)
		M.Correlation	=> sm.correlation(a, b)
		M.Cosine		=> sm.cosine(a, b)
		M.Camberra		=> sm.camberra(a, b)
		M.MAE			=> sm.mae(a, b)
		M.MSE			=> sm.mse(a, b)
		M.Lorentzian	=> sm.lorentzian(a, b)
		M.Intersection	=> sm.intersection(a, b)
		M.PenroseShape	=> sm.penrose(a, b)
		M.Meehl			=> sm.meehl(a, b)

//#endregion
//#region	Inputs:

enum MSRC
	R  = 'Returns'
	RV = 'Volume Modified Returns'

int window = input.int(10, 'Window:')
MSRC srcmethod = input.enum(MSRC.R, 'Source Method:')
M mmethod = input.enum(M.Cosine, 'Similarity Measure Method:')
string tickers = input.text_area('NAS100,SPX500,DJI, IBXX, N100, EU500, UKX, JP225USD, NIFTY, CN50USD, HSI, NZ50G, MOEX', 'Asset List:')
color grad1 = input.color(color.maroon, 'Gradient Colors:', inline='1')
color grad2 = input.color(color.blue, '', inline='1')
int ndigits = input.int(5, 'Number of Digits:')

var string fdigits = '0.'
if barstate.isfirst
	for _i = 1 to ndigits
		fdigits += '0'

sec (string t) => 
	float _src = na
	switch srcmethod
		MSRC.R => _src := close / close[1]
		MSRC.RV => float _v = nz(volume, 1.0) , _src := (close * _v) / (close[1] * _v[1])
	request.security(t, timeframe.period, _src, barmerge.gaps_off, barmerge.lookahead_on)


//#endregion
//#region	Import indices data:

var string[] tlist = str.split(str.replace_all(tickers, ' ', ''), ',')
int tsize = tlist.size()
// @variable Matrix to hold the indice values for the length of the window.
var matrix<float> tvalues = matrix.new<float>(window, tsize, float(na))
// @variable Temporary array to hold current indice values.
float[] lastvalues = array.new<float>(tsize, float(na))
for [_i, _t] in tlist
	lastvalues.set(_i, sec(_t))
tvalues.add_row(window, lastvalues)
if tvalues.rows() > window
	tvalues.remove_row(0)

//#endregion
//#region	Calculate the measure of the indices:

// @variable similarity measure values
matrix<float> cs = matrix.new<float>(tsize, tsize, float(na))
for _i = 0 to tsize - 1
	_ri = tvalues.col(_i)
	for _j = 0 to tsize - 1
		if _i == _j
			continue
		_rj = tvalues.col(_j)
		cs.set(_i, _j, select(mmethod, _ri, _rj))
// @variable matrice highest value.
float smax = cs.max()
// @variable matrice lowest value.
float smin = cs.min()

// @function Color the table values.
col (v) => 
	float _v = (v - smin) / (smax - smin)
	color.from_gradient(_v, 0, 1, grad1, grad2)

//#endregion
//#region
var table TB = table.new(position.bottom_right, tsize+1, tsize+1, #000000, #ffffff, 1)
for [_i, _t] in tlist
	TB.cell(0, 1+_i, _t, 0, 0, #ffffff, text.align_center, text.align_center, 14, #000000)
	TB.cell(1+_i, 0, _t, 0, 0, #ffffff, text.align_center, text.align_center, 14, #000000)
	for _j = 0 to tsize-1
		float _sv = cs.get(_i, _j)
		if _i == _j
			TB.cell(1+_i, 1+_j, str.format('{0}', _t), 0, 0, #ffffff, text.align_center, text.align_center, 14, #000000)
		else
			TB.cell(1+_i, 1+_j, str.format('{0}', str.tostring(_sv, fdigits)), 0, 0, #ffffff, text.align_center, text.align_center, 14, col(_sv))
