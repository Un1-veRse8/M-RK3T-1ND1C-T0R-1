// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © shui2967

//@version=5
indicator("Neural Adaptive VWAP", shorttitle="Neural-VWAP", overlay=true)

// ===== INPUT PARAMETERS =====
vwap_length = input.int(20, title="VWAP Length", minval=1, maxval=200)
volume_lookback = input.int(14, title="Volume Pattern Lookback", minval=5, maxval=50)
adaptation_period = input.int(10, title="Adaptation Period", minval=5, maxval=30)
learning_rate = input.float(0.01, title="Learning Rate", minval=0.001, maxval=0.1, step=0.001)
prediction_horizon = input.int(3, title="Prediction Horizon", minval=1, maxval=10)

// Source for VWAP calculation
src = input.source(ohlc4, title="VWAP Source")

// ===== VOLUME PATTERN ANALYSIS =====
// Create volume features similar to what LSTM would use
vol_sma = ta.sma(volume, volume_lookback)
vol_std = ta.stdev(volume, volume_lookback)
vol_normalized = vol_std > 0 ? (volume - vol_sma) / vol_std : 0

// Time-of-day features (simulating temporal patterns)
hour_of_day = hour(time)
minute_of_hour = minute(time)
time_factor = math.sin(2 * math.pi * hour_of_day / 24) + 0.5 * math.sin(2 * math.pi * minute_of_hour / 60)

// Price momentum features
price_change = ta.change(close)
price_momentum = ta.roc(close, 5)
volatility = close > 0 ? ta.atr(14) / close : 0

// ===== ADAPTIVE WEIGHT SYSTEM =====
// Simulate neural network weights that adapt over time
var float w1 = 0.3
var float w2 = 0.2
var float w3 = 0.25
var float w4 = 0.15
var float w5 = 0.1

// Features for volume prediction
feature1 = vol_normalized
feature2 = time_factor
feature3 = price_momentum
feature4 = volatility
feature5 = vol_sma > 0 ? ta.change(volume, 2) / vol_sma : 0

// ===== VOLUME PREDICTION (LSTM-INSPIRED) =====
// Weighted combination of features (simulating neural network output)
predicted_vol_factor = w1 * feature1 + w2 * feature2 + w3 * feature3 + w4 * feature4 + w5 * feature5

// Apply activation function (sigmoid-like)
sigmoid(x) => 1 / (1 + math.exp(-math.max(-10, math.min(10, x))))
activated_prediction = sigmoid(predicted_vol_factor)

// Scale prediction to realistic volume range
predicted_volume = vol_sma * (0.5 + activated_prediction)

// ===== ADAPTIVE LEARNING =====
// Simple error calculation and weight adjustment
if bar_index > volume_lookback and not na(predicted_volume[1])
    error = volume - predicted_volume[1]
    
    // Clamp error to prevent extreme updates
    error := math.max(-vol_sma, math.min(vol_sma, error))
    
    // Update weights based on error (simplified backpropagation)
    if not na(feature1[1])
        w1 := w1 + learning_rate * error * feature1[1] / vol_sma
    if not na(feature2[1])
        w2 := w2 + learning_rate * error * feature2[1] / vol_sma
    if not na(feature3[1])
        w3 := w3 + learning_rate * error * feature3[1] / vol_sma
    if not na(feature4[1])
        w4 := w4 + learning_rate * error * feature4[1] / vol_sma
    if not na(feature5[1])
        w5 := w5 + learning_rate * error * feature5[1] / vol_sma
    
    // Normalize weights to prevent explosion
    total_weight = math.abs(w1) + math.abs(w2) + math.abs(w3) + math.abs(w4) + math.abs(w5)
    if total_weight > 2.0
        w1 := w1 / total_weight * 1.0
        w2 := w2 / total_weight * 1.0
        w3 := w3 / total_weight * 1.0
        w4 := w4 / total_weight * 1.0
        w5 := w5 / total_weight * 1.0

// ===== PROPER SESSION-BASED VWAP RESET =====
// Fix the VWAP reset logic to prevent plotting anomalies
new_session = ta.change(time('D'))
var float session_cum_vol_price = 0.0
var float session_cum_vol = 0.0
var int bars_in_session = 0

// Reset on new session
if new_session
    session_cum_vol_price := 0.0
    session_cum_vol := 0.0
    bars_in_session := 0

// Use actual volume, not predicted for VWAP calculation
volume_weight = math.max(volume, 1) // Ensure minimum volume of 1
session_cum_vol_price := session_cum_vol_price + (src * volume_weight)
session_cum_vol := session_cum_vol + volume_weight
bars_in_session := bars_in_session + 1

// Calculate adaptive VWAP with safety checks
adaptive_vwap = session_cum_vol > 0 ? session_cum_vol_price / session_cum_vol : src

// ===== CONFIDENCE BANDS =====
// Calculate rolling standard deviation for bands
lookback_for_std = math.min(bars_in_session, 50)
price_series = src
vwap_diff = src - adaptive_vwap
rolling_std = ta.stdev(vwap_diff, lookback_for_std)

// Create bands with safety checks
std_multiplier = 1.5
upper_band = adaptive_vwap + (rolling_std * std_multiplier)
lower_band = adaptive_vwap - (rolling_std * std_multiplier)

// ===== PLOTTING WITH TRANSPARENCY FIX =====
// Fix plotting anomalies by using transparent colors after session reset
vwap_color = new_session ? color.new(color.blue, 100) : color.blue
upper_color = new_session ? color.new(color.red, 100) : color.red
lower_color = new_session ? color.new(color.green, 100) : color.green

// Plot adaptive VWAP
vwap_plot = plot(adaptive_vwap, title="Adaptive VWAP", color=vwap_color, linewidth=2)

// Plot confidence bands
upper_plot = plot(upper_band, title="Upper Band", color=upper_color, linewidth=1)
lower_plot = plot(lower_band, title="Lower Band", color=lower_color, linewidth=1)

// Fill between bands with transparency
fill_color = new_session ? color.new(color.gray, 100) : color.new(color.gray, 90)
fill(upper_plot, lower_plot, color=fill_color, title="Confidence Zone")

// ===== SIGNALS WITH VOLUME CONFIRMATION =====
// Generate trading signals based on adaptive VWAP
volume_threshold = vol_sma * 1.2
long_signal = ta.crossover(close, adaptive_vwap) and volume > volume_threshold and not new_session
short_signal = ta.crossunder(close, adaptive_vwap) and volume > volume_threshold and not new_session

// Plot signals
plotshape(long_signal, title="Long Signal", style=shape.triangleup, location=location.belowbar, 
          color=color.green, size=size.small)
plotshape(short_signal, title="Short Signal", style=shape.triangledown, location=location.abovebar, 
          color=color.red, size=size.small)

// ===== CANDLE COLORING BASED ON VWAP =====
// Color candles based on position relative to VWAP
above_vwap = close > adaptive_vwap
below_vwap = close < adaptive_vwap
strong_above = close > upper_band
strong_below = close < lower_band

candle_color = strong_above ? color.lime :
               above_vwap ? color.green :
               strong_below ? color.red :
               below_vwap ? color.orange : color.gray

barcolor(candle_color)

// ===== INFORMATION TABLE =====
if barstate.islast
    var table info_table = table.new(position.top_right, 2, 7, bgcolor=color.white, border_width=1)
    
    table.cell(info_table, 0, 0, "Metric", text_color=color.black, bgcolor= color.gray)
    table.cell(info_table, 1, 0, "Value", text_color=color.black, bgcolor=color.gray)
    
    table.cell(info_table, 0, 1, "Predicted Vol", text_color=color.black)
    table.cell(info_table, 1, 1, str.tostring(math.round(predicted_volume)), text_color=color.black)
    
    table.cell(info_table, 0, 2, "Actual Vol", text_color=color.black)
    table.cell(info_table, 1, 2, str.tostring(volume), text_color=color.black)
    
    table.cell(info_table, 0, 3, "VWAP", text_color=color.black)
    table.cell(info_table, 1, 3, str.tostring(adaptive_vwap, "#.####"), text_color=color.black)
    
    table.cell(info_table, 0, 4, "Bars in Session", text_color=color.black)
    table.cell(info_table, 1, 4, str.tostring(bars_in_session), text_color=color.black)
    
    table.cell(info_table, 0, 5, "Weight Sum", text_color=color.black)
    table.cell(info_table, 1, 5, str.tostring(w1 + w2 + w3 + w4 + w5, "#.###"), text_color=color.black)
    
    table.cell(info_table, 0, 6, "Rolling Std", text_color=color.black)
    table.cell(info_table, 1, 6, str.tostring(rolling_std, "#.####"), text_color=color.black)

// ===== ALERTS =====
alertcondition(long_signal, title="LSTM VWAP Long", message="Adaptive VWAP Long Signal")
alertcondition(short_signal, title="LSTM VWAP Short", message="Adaptive VWAP Short Signal")
