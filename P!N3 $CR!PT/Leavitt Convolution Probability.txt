// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © dPEngineering
// Accoridng to Leavitt article: 
//"A large rise in this probability often precedes a market fall with the reverse forecasting a bullish move."

//@version=6
indicator("Leavitt Convolution Probability", shorttitle = "Conv Prob", overlay = false)

//Inputs
length = input.int (25, title = "Linear Regression length")
convolutionLength = input.int (5, title = "Convolution length")
overBought = input.int (80, title = "Overboutgh Probability")
overSold = input.int (20, title = "Oversold Probability")
offset = input.int (1, title = "Convolution offset")

//Leavitt functions
leavittProjection(float src, int _length) =>
    float result = ta.linreg(src, _length, offset)
    
leavittConvolution(float src, int _length) =>
    int sqrtLength = math.floor(nz(math.sqrt(_length)))
    float result = ta.linreg(leavittProjection(src, _length), sqrtLength, offset)

convolution = leavittConvolution(close, convolutionLength)

// Slope and intercept  calculation
calcSlope(source, length) =>
    max_bars_back(source, 5000)

    sumX = 0.0
    sumY = 0.0
    sumXSqr = 0.0
    sumXY = 0.0
    for i = 0 to length - 1 by 1
        val = source[i]
        per = i + 1.0
        sumX := sumX + per
        sumY := sumY + val
        sumXSqr := sumXSqr + per * per
        sumXY := sumXY + val * per
        sumXY
    slope = (length * sumXY - sumX * sumY) / (length * sumXSqr - sumX * sumX)
    average = sumY / length
    intercept = average - slope * sumX / length + slope
    [slope, average, intercept]

[slope,average,intercept] = calcSlope(convolution, length)

// Mean slope and intercept
meanSlope = ta.sma(slope,length)
meanIntercept = ta.sma(intercept,length)

// Standard deviation Calculation of slope and intercept
stdDevSlope = ta.stdev(meanSlope, length)
stdDevIntercept = ta.stdev(meanIntercept, length)

// Score of slope and intercept: this is needed for next formula
zSlope = (slope - meanSlope) / stdDevSlope
zIntercept = (intercept - meanIntercept) / stdDevIntercept

// CDF calculation using an aproximity formula
probabilitySlope = 0.5 * (1 + (math.sign(zSlope) * math.sqrt(1 - math.exp(-0.5 * zSlope * zSlope)))) 
probabilityIntercept = 0.5 * (1 + (math.sign(zIntercept) * math.sqrt(1 - math.exp(-0.5 * zIntercept * zIntercept))))

// Convolution Probability
convolutionProbability = 100*(probabilitySlope * (1-probabilityIntercept))

// Plot
linecolor(data) =>
    linecolor = color.blue
    if convolutionProbability > overBought
        linecolor := color.red
    else if convolutionProbability < overSold
        linecolor := color.green
    else 
        linecolor := color.blue

CP = plot(convolutionProbability, title="Convolution Probability", color =linecolor(convolution))
topVal = 100 
botVal = 0 
topCol = color.new(color.red,80)
botCol = color.new(color.green,80)
short = hline(overBought, title = "Overbought line", linestyle =  hline.style_dotted, color = color.gray)
long = hline(overSold, title = "Oversold line", linestyle =  hline.style_dotted, color = color.gray)
_100 = hline (100, display =display.none)
_0 = hline (0, display =display.none)
_50 = hline (50, title = "Middle line", linestyle =  hline.style_dashed,color = color.gray)
fill (short,_100, color =topCol)
fill (long,_0, color = botCol)
fill(short, long, topVal, botVal, topCol, botCol)
plot (convolution, title = "Convolution", force_overlay = true, color = color.blue)