
// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Honestcowboy

//@version=6
indicator(shorttitle = 'Box Stats', title = 'Range Breakout Statistics [Honestcowboy]', overlay = false, max_boxes_count = 500, max_labels_count = 500, max_bars_back = 2000, max_polylines_count= 100)
import MUQWISHI/colorLab/1 as colorlab

//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//> --------> Curated Color Templates <-------- //> °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
cTemp = input.string(defval="Awake", title="Visual Template", options=["Awake", "Zesty", "Metaverse", "Bold", "Magnet"], group="Quick Visuals")
// Awake -- https://connect.pantone.com/#/color-insider/awake-color-direction-spring-summer-2026-graphics-and-branding
// Minimalist sense of calm, sophistication, luxury and minfulness
// 1: A delicate interplay of light and shadow unfolds in a softly transitioning cool color harmony. Gentle white gradually shifts into light gray,
// deepening into a rich, darker gray. Calm and minimal, this composition evokes a sense of weightlessness and quiet balance.
// 2: A soft, warm, and neutral color harmony draws the eye throught its gentle, calming transition. The beige tones are subtly complemented by the tender,
// slightly more pigmented hue of Peach Whip, adding a delicate touch of warmth. Castlerock introduces a shadow-rich accent with its deep,
// grounding presence, creating a refined contrast withing the serene palette.
// 3: A cool-toned harmony that evokes both hazy stillness and ethereal airiness. The whisper of blue in Spa Blue is beautifully connected
// to the cooler gray withing the palette through the subtle shimmer of the metallic tone, acting as a delicate bridge between softness and clarity.
// 4: In this harmony, the soft, warm, and comforting beige tones of the color palette are seamlessly connected with neutral, cool gray shades.
// A gentle transition from light white to deeper gray creates subtle color gradations, enhancing the soothing elegance of this composition.
cSnowWhite = #F2F0EB // 1 // 4
cPumiceStone = #CAC2B9 // 2 // 4
cDoeSkin = #BDAB9B // 2
cSpaBlue = #D3DEDF // 3
cPeachWhip = #DBBEB7 // 2
cDrizzle = #A09E9C // 1 // 4
cCastlerock = #5F5E62 // 1 // 2 // 3 // 4
cSilverShadow = #939097 // 3


// Imagination -- https://connect.pantone.com/#/color-insider/imagination-color-direction-spring-summer-2026-graphics-and-branding
// Surreal dreamlike, hyperreal AI aesthetics, Bold, psychedelic, electrifying, digital
// 1: This is a dreamy harmony where softer tones are contrasted with a touch of vibrant power.
// As the colors morph together, they create a psychedelic image, blending into one unified whole despite their inherent contrasts.
// 2: The strong digital allure of metaverse-inspired blues is softened by the gentle counterpart of Pastel Lilac.
// These colors flow together like a dreamscape, creating a surreal atmosphere. The bright Fuchsia Purple adds a vibrant accent, enhancing the overall energy.
// 3: The digital attraction of Lemon Verbena evokes a zesty, acid-based harmony. This energetic yellow seamlessly transitions into Summer Green.
// Together, they stand in bold contrast to the vibrant sweetness of Flamingo Pink.
// 4: This is a harmonious color gradient where the hues effortlessly blend into each other. It's dreamy and soft, yet each color stands strongly on its own.
// The fresh blues and greens create a deeper contrast against the energetic yellow, while Peach Quartz spreads a psychedelic softness.
cSummerGreen = #7FD37F // 3 // 4
cLemonVerbena = #F4E87A // 1 // 3 // 4
cPastelLilac = #BCAFCF // 2
cPeachQuartz = #F5B895 // 4
cFlamingoPink = #F7969E // 1 // 3
cFuchsiaPurple = #D4367A // 1 // 2
cBlueIris = #5A5B9F // 2
cBlueAtoll = #00B1D2 // 1 // 2 // 4

// Sensory -- https://connect.pantone.com/#/color-insider/sensory-color-direction-spring-summer-2026-graphics-and-branding
// Inviting, Openess, touch, tender and sensual, feeling, softness, dreamlike, gradient, glassy materials
// 1: A sensual interplay of the pink and lilac tones from the color palette. This harmony is tender yet captivating, used in both opaque color combinations and translucent
// applications for ethereal, futuristic, and dreamlike designs. The alluring shades evoke a sense of cosmetic elegance and sensuality, with each hue engaging our senses.
// 2: The soft, illuminating light of Pear Sorbet brings a seductive glow to graphic expressions and packaging designs. Gently radiant and subtly luminous,
// this shade engages our senses. In perfect harmony with the cool Open Air, together they create a dreamlike, blurred reality.
// 3: This harmony showcases a beautiful gradient transition, where glowing light plays a seductive role. A balance from light to dark, tender and sensual,
// yet with a deep, mysterious allure. Colors blend seamlessly, illuminated by a soft hint of yellow.
// 4: This is a balanced harmony of shadowy coolness, translucent tones, and a seductive sensation. Moving from light to dark, from cool airy tones to
// a grounded earthy dark. Blending our earthly world with the digital and artificial, harmoniously yet with a virtual aesthetic.
cPearSorbet = #F3EAC3 // 2 // 3
cCarnelian = #CE785D // 3
cCameoBrown = #C08A80 // 1 // 3
cPhloxPink = #CE5E9A // 1
cLavenderFog = #D2C4D6 // 1 // 4
cOpenAir = #94B2DF // 2 // 4
cCrownBlue = #464B65 // 4
cMarron = #6E4C4B // 3 // 4


// Creating -- https://connect.pantone.com/#/color-insider/creating-color-direction-spring-summer-2026-graphics-and-branding
// transformative, conceptual, product, magnetism, commands attention, dynamic, bold, fearless energy, optimism
// 1: A surprising and higly expressive color harmony inspired by boundless creativity, personal connection and vibrant energy. The neutral warmth of Dusty Coral
// forms an unexpected contrast against the bold intensity of bright yellow and rich green in this dynalic composition. Meanwhile, Carbon introduces depth and balance,
// providing a shadowy contrast that grounds the harmony.
// 2: An ultra-contrasting color harmony where shades both complement and oppose each other. Playful yet powerful, they interact dynamically in string creativity.
// The deep blues and vibrant yellows create a graphic contrast, further intensified by a darker anchor. 
// Meanwhile, Wild Orchid introduces a playful and optimistic element, adding vibrancy and depth.
// 3: The intense reddish orange of Tangerine Tango set against the muted warmth of Dusty Coral. This pairing creates a tonal gradient that also delivers
// a surprising color contrast, ideal for graphic compositions with dynamic visual impact.
// 4: This color harmony blends warm, vibrant hues with cool, dark contrasts, resulting in a palette that's both radiantly impactful and boldly intense. 
// It captures the interplay between light and shadow, striking the perfect balance between energetic brightness and contrasting depth
// in a combination designed to leave a striking impression.
cDirectoireBlue = #0061A3 // 2 // 4
cSimplyGreen = #009B74 // 1
cBrilliantWhite = #EDF1FF
cFreesia = #F3C12C // 1 // 2
cDustyCoral = #D29B83 // 1 // 3
cTangerineTango = #DD4124 // 3 // 4
cWildOrchid = #D979A2 // 2 // 4
cCarbon = #272F38 // 1 // 2 // 4


polyBullAverages_C = cTemp == "Awake" ? cSilverShadow : cTemp == "Zesty" ? cSummerGreen : cTemp == "Metaverse" ? cBlueAtoll : cTemp == "Bold" ? cSimplyGreen : cTemp == "Magnet" ? cDirectoireBlue : na
polyBearAverages_C = cTemp == "Awake" ? cCastlerock : cTemp == "Zesty" ? cFlamingoPink : cTemp == "Metaverse" ? cFuchsiaPurple : cTemp == "Bold" ? cFreesia : cTemp == "Magnet" ? cTangerineTango : na
tinyRangePolyBull_C = cTemp == "Awake" ? cSilverShadow : cTemp == "Zesty" ? cSummerGreen : cTemp == "Metaverse" ? cBlueAtoll : cTemp == "Bold" ? cSimplyGreen : cTemp == "Magnet" ? cDirectoireBlue : na
tinyRangePolyBear_C = cTemp == "Awake" ? cCastlerock : cTemp == "Zesty" ? cFlamingoPink: cTemp == "Metaverse" ? cFuchsiaPurple : cTemp == "Bold" ? cFreesia : cTemp == "Magnet" ? cTangerineTango : na
tinyRangePolyBullBg_C = cTemp == "Awake" ? color.new(cSpaBlue, 60) : cTemp == "Zesty" ? color.new(cSummerGreen, 60) : cTemp == "Metaverse" ? color.new(cBlueAtoll, 60) : cTemp == "Bold" ? color.new(cSimplyGreen, 60) : cTemp == "Magnet" ? color.new(cDirectoireBlue, 60) : na
tinyRangePolyBearBg_C = cTemp == "Awake" ? color.new(cPeachWhip, 60) : cTemp == "Zesty" ? color.new(cFlamingoPink, 60): cTemp == "Metaverse" ? color.new(cFuchsiaPurple, 60) : cTemp == "Bold" ? color.new(cFreesia, 60) : cTemp == "Magnet" ? color.new(cTangerineTango, 60) : na

bullBarColor = cTemp == "Awake" ? cSilverShadow : cTemp == "Zesty" ? cSummerGreen : cTemp == "Metaverse" ? cBlueAtoll : cTemp == "Bold" ? cSimplyGreen : cTemp == "Magnet" ? cDirectoireBlue : na
bearBarColor = cTemp == "Awake" ? cCastlerock : cTemp == "Zesty" ? cFlamingoPink: cTemp == "Metaverse" ? cFuchsiaPurple : cTemp == "Bold" ? cFreesia : cTemp == "Magnet" ? cTangerineTango : na
bullLabelTextColor = cTemp == "Awake" ? cCastlerock : cTemp == "Zesty" ? cBlueIris : cTemp == "Metaverse" ? cBlueIris : cTemp == "Bold" ? cCarbon : cTemp == "Magnet" ? cCarbon : na
bearLabelTextColor = cTemp == "Awake" ? cCastlerock : cTemp == "Zesty" ? cBlueIris : cTemp == "Metaverse" ? cBlueIris : cTemp == "Bold" ? cCarbon : cTemp == "Magnet" ? cCarbon : na
bullLabelColor = cTemp == "Awake" ? cSpaBlue : cTemp == "Zesty" ? cSummerGreen : cTemp == "Metaverse" ? cBlueAtoll : cTemp == "Bold" ? cSimplyGreen : cTemp == "Magnet" ? cDirectoireBlue : na
bearLabelColor = cTemp == "Awake" ? cPeachWhip : cTemp == "Zesty" ? cFlamingoPink : cTemp == "Metaverse" ? cFuchsiaPurple : cTemp == "Bold" ? cFreesia : cTemp == "Magnet" ? cTangerineTango : na
equityBull_C = cTemp == "Awake" ? cSpaBlue : cTemp == "Zesty" ? cSummerGreen : cTemp == "Metaverse" ? cBlueAtoll : cTemp == "Bold" ? cSimplyGreen : cTemp == "Magnet" ? cDirectoireBlue : na
equityBear_C = cTemp == "Awake" ? cDoeSkin : cTemp == "Zesty" ? cFlamingoPink : cTemp == "Metaverse" ? cFuchsiaPurple : cTemp == "Bold" ? cFreesia : cTemp == "Magnet" ? cTangerineTango : na
var int equityLine_Width = cTemp == "Awake" ? 1 : cTemp =="Zesty" ? 1 : cTemp == "Metaverse" ? 1 : cTemp == "Bold" ? 1 : cTemp == "Magnet" ? 1 : 1
//"lightness" for Awake template //"lightness" for Zesty template
colorMethod = "lightness"
MAColor = cTemp == "Awake" ? cCastlerock : cTemp == "Zesty" ? cBlueIris : cTemp == "Metaverse" ? cPastelLilac : cTemp == "Bold" ? cDustyCoral : cTemp == "Magnet" ? cWildOrchid : na
var int MAWidth = cTemp == "Awake" ? 1 : cTemp == "Zesty" ? 1 : cTemp == "Metaverse" ? 1 : 1
slopeColor = cTemp == "Awake" ? cSilverShadow : cTemp == "Zesty" ? cSummerGreen : cTemp == "Metaverse" ? cBlueAtoll : cTemp == "Bold" ? cSimplyGreen : cTemp == "Magnet" ? cDirectoireBlue : na
slopeBelowColor = cTemp == "Awake" ? cDoeSkin : cTemp == "Zesty" ? cFlamingoPink : cTemp == "Metaverse" ? cFuchsiaPurple : cTemp == "Bold" ? cFreesia : cTemp == "Magnet" ? cTangerineTango: na
upperSlopeColor = cTemp == "Awake" ? cCastlerock : cTemp == "Zesty" ? cBlueIris : cTemp == "Metaverse" ? cPastelLilac : cTemp == "Bold" ? cDustyCoral : cTemp == "Magnet" ? cWildOrchid : na

tinyBox_C = cTemp == "Awake" ? cSilverShadow : cTemp == "Zesty" ? cFlamingoPink : cTemp == "Metaverse" ? cFuchsiaPurple : cTemp == "Bold" ? cFreesia : cTemp == "Magnet" ? cTangerineTango : na
tinyBox_Width = cTemp == "Awake" ? 1 : cTemp == "Zesty" ? 1 : cTemp == "Metaverse" ? 1 : cTemp == "Bold" ? 1 : cTemp == "Magnet" ? 1 : 1
tinyBox_bgC = cTemp == "Awake" ? color.new(cPumiceStone, 50) : cTemp == "Zesty" ? color.new(cSummerGreen, 50) : cTemp == "Metaverse" ? color.new(cPastelLilac, 60) : cTemp == "Bold" ? color.new(cDustyCoral, 60) : cTemp == "Magnet" ? color.new(cWildOrchid, 70) : na
bgColor = cTemp == "Awake" ? cSnowWhite : cTemp == "Zesty" ? cLemonVerbena : cTemp == "Metaverse" ? cBlueIris : cTemp == "Bold" ? cCarbon : cTemp == "Magnet" ? cCarbon : na

//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//> ---------> User Input <----------- //> °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
gatherData          = input.bool(defval=true, title='Gather DATA (IMPORTANT)', group='[Box Stats]', tooltip ='Disabling this will make the script not gather any data for projections and not project at all. This is for smooth running a script if you do not want to look at data or just let alerts run without errors')
projectionLength    = input.int(defval=200, maxval=499, minval=2, title='Projection Length', group='[Box Stats]')
maxStatsHistory     = 500

projectionType      = input.string(defval="Averages Projection", title="Projection Type", options=["Averages Projection", "Equity Simulation"], group="[Box Stats]")
tinyBoxStatsGroup   = '[Box Stats] Averages Projection'
tinyAvgMethod       = input.string(defval="Geometric Average", title="Calculation Method", options=["Geometric Average", "Arithmetic Average", "Median"], group=tinyBoxStatsGroup)
showTinyRangePolys  = input.bool(defval=true, title='Price Action Boundaries', group=tinyBoxStatsGroup, inline='1')
showExtremes        = input.bool(defval=true, title="Extremes (highs, lows)", group=tinyBoxStatsGroup, inline='1')
minHoldingTime      = input.int(defval=0, minval=0, title='Min Holding time (bars)', group='[Box Stats] Equity Simulation')
maxHoldingTime      = input.int(defval=10, minval=0, title='Max Holding time (bars)', group='[Box Stats] Equity Simulation')

length              = input.int(defval=5, minval=1, group='[Box Detect] Moving Average')
src                 = close
maType              = input.string(defval='SMA', options=['SMA', 'DONCHIAN'], title='MA Method', group='[Box Detect] Moving Average')
slopePeriod         = input.int(defval=2, minval=1, title='Slope Period', group='[Box Detect] Consolidation Detection')
cons_period         = input.int(defval=25, minval=1, title='Consolidation Length for breakout', group='[Box Detect] Consolidation Detection')

max_bars_breakout   = input.int(defval=100, minval=2, title='Maximum Bars before Breakout', group='[Box Detect] Box Filtering')
onlyUseFirstBreak   = true

useATR              = input.bool(defval=true, title='Use ATR?', group='[Box Detect] Box Filtering', inline='ATR')
atrLength           = input.int(defval=14, minval=2, title='Length', group='[Box Detect] Box Filtering', inline='ATR')
tinyBoxPerc         = input.float(defval=30, minval=0, title='Box Max %', group='[Box Detect] Box Filtering', inline='tiny')

//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//> -----> Immutable Constants <------ //> °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//Box Variablex
var float boxHigh = na
var float boxLows = na
var float avgUpperSlope = na
type boxStats
	bool stopLooking = false
	int upperBreakPoint = na
	int lowerBreakPoint = na
	float boxMedianSlope = na
	box boxDrawing = na

var tinyBoxes = array.new<boxStats>()

var tinyUpperBreakArray = array.new<float>(projectionLength)
var tinyLowerBreakArray = array.new<float>(projectionLength)
var tinyUpperBreakHighArray = array.new<float>(projectionLength)
var tinyLowerBreakHighArray = array.new<float>(projectionLength)
var tinyUpperBreakLowsArray = array.new<float>(projectionLength)
var tinyLowerBreakLowsArray = array.new<float>(projectionLength)

var tinyUpperBreakMatrix = matrix.new<float>()
var tinyLowerBreakMatrix = matrix.new<float>()
var tinyUpperBreakHighMatrix = matrix.new<float>()
var tinyLowerBreakHighMatrix = matrix.new<float>()
var tinyUpperBreakLowsMatrix = matrix.new<float>()
var tinyLowerBreakLowsMatrix = matrix.new<float>()

// 0 for avg :: 1 for median :: 2 for max :: 3 for min :: 4 for geoAvg
var tinyUpperFinalMatrix = matrix.new<float>(5, projectionLength)
var tinyLowerFinalMatrix = matrix.new<float>(5, projectionLength)
var tinyUpperFinalHighMatrix = matrix.new<float>(5, projectionLength)
var tinyLowerFinalHighMatrix = matrix.new<float>(5, projectionLength)
var tinyUpperFinalLowsMatrix = matrix.new<float>(5, projectionLength)
var tinyLowerFinalLowsMatrix = matrix.new<float>(5, projectionLength)

// 0 for avg :: 1 for median :: 2 for maxmin range :: 3 for equitySim
var tinyUpperFinalPolys = array.new<polyline>(7)
var tinyLowerFinalPolys = array.new<polyline>(7)

var upperFinalTableStats = array.new<float>(2)
var lowerFinalTableStats = array.new<float>(2)

// Equity Simulation Arrays
var int simulationSize = math.max(minHoldingTime, maxHoldingTime)-math.min(minHoldingTime, maxHoldingTime)+1
var tinyUpperEquityPolys = array.new<polyline>(simulationSize)
var tinyLowerEquityPolys = array.new<polyline>(simulationSize)
var tinyUpperEquityLabels = array.new<label>(simulationSize)
var tinyLowerEquityLabels = array.new<label>(simulationSize)


//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//> ---> Functional Declarations <---- //> °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
atr = ta.atr(atrLength)

donchian(len) =>
    math.avg(ta.lowest(len), ta.highest(len))

_arrayLoad(_x, _max, _val) =>
    array.unshift(_x, _val)
    if array.size(_x) > _max
        array.pop(_x)

geometric_average(arr) =>
    totalProduct = 1.0
    for i = 0 to array.size(arr) - 1
        r = array.get(arr, i)
        totalProduct := totalProduct * (1 + r)
    
    n = array.size(arr)
    float result = na
    if n > 0
        result := math.pow(totalProduct, 1 / n) - 1
    result

_matrixPush(_mx, _max, _row) =>
    matrix.add_row(_mx, matrix.rows(_mx), _row)
    if matrix.rows(_mx) > _max
        matrix.remove_row(_mx, 0)

_matrixColumnsAvgToArray(_matrix, _array) =>
    if _matrix.rows() >= 1 and _matrix.columns() >= 1
        for i = _matrix.columns() - 1 to 0 by 1
            a = _matrix.col(i)
            b = a.avg()
            _array.set(i, b)

_matrixColumnsMedianToArray(_matrix, _array) =>
    if _matrix.rows() >= 1 and _matrix.columns() >= 1
        for i = _matrix.columns() - 1 to 0 by 1
            a = _matrix.col(i)
            b = a.median()
            _array.set(i, b)

_matrixColumnsMaxToArray(_matrix, _array) =>
    if _matrix.rows() >= 1 and _matrix.columns() >= 1
        for i = _matrix.columns() - 1 to 0 by 1
            a = _matrix.col(i)
            b = a.max()
            _array.set(i, b)

_matrixColumnsMinToArray(_matrix, _array) =>
    if _matrix.rows() >= 1 and _matrix.columns() >= 1
        for i = _matrix.columns() - 1 to 0 by 1
            a = _matrix.col(i)
            b = a.min()
            _array.set(i, b)

_matrixColumnsGeoAvgToArray(_matrix, _array) =>
    if _matrix.rows() >= 1 and _matrix.columns() >= 1
        for i = _matrix.columns() - 1 to 0 by 1
            a = _matrix.col(i)
            b = geometric_average(a)
            _array.set(i, b)

_matrixCalculationsToMatrix(_matrixStart, _matrixEnd, projectionLength) =>
    avg = array.new<float>(projectionLength)
    median = array.new<float>(projectionLength)
    max = array.new<float>(projectionLength)
    min = array.new<float>(projectionLength)
    geoAvg = array.new<float>(projectionLength)
    _matrixColumnsAvgToArray(_matrixStart, avg)
    _matrixColumnsMedianToArray(_matrixStart, median)
    _matrixColumnsMaxToArray(_matrixStart, max)
    _matrixColumnsMinToArray(_matrixStart, min)
    _matrixColumnsGeoAvgToArray(_matrixStart, geoAvg)
    _matrixPush(_matrixEnd, 5, avg)
    _matrixPush(_matrixEnd, 5, median)
    _matrixPush(_matrixEnd, 5, max)
    _matrixPush(_matrixEnd, 5, min)
    _matrixPush(_matrixEnd, 5, geoAvg)

_projectionFill(_x, _projectionLength, breakPoint) =>
    for i = 1 to _projectionLength by 1
        _arrayLoad(_x, _projectionLength, (close[i] - breakPoint) / breakPoint)

_projectionHighFill(_x, _projectionLength, breakPoint) =>
    for i = 1 to _projectionLength by 1
        _arrayLoad(_x, _projectionLength, (high[i] - breakPoint) / breakPoint)

_projectionLowsFill(_x, _projectionLength, breakPoint) =>
    for i = 1 to _projectionLength by 1
        _arrayLoad(_x, _projectionLength, (low[i] - breakPoint) / breakPoint)

_projectionPointsFromMatrix(_referenceMatrix, _matrixRow, _pointsArray, _projectionLength, startIndex, startPrice) =>
    for i = _projectionLength - 1 to 0 by 1
        point = chart.point.from_index(startIndex + i + 1, startPrice + matrix.get(_referenceMatrix, _matrixRow, i) * startPrice)
        array.set(_pointsArray, i + 1, point)
        if i == 0
            startPoint = chart.point.from_index(startIndex, startPrice)
            array.set(_pointsArray, 0, startPoint)

_getEquityArray(_refMatrix, _pointsArray, bar, startIndex, startPrice) =>
    if _refMatrix.rows() >= 1 and _refMatrix.columns() >= 1
        previousPrice = startPrice
        for i = 0 to _refMatrix.rows() - 1 by 1
            if i == 0
                startPoint = chart.point.from_index(startIndex, startPrice)
                array.set(_pointsArray, 0, startPoint)
            point = chart.point.from_index(startIndex + i + 1, (previousPrice * (1+matrix.get(_refMatrix, i, bar))))
            array.set(_pointsArray, i + 1, point)
            previousPrice := previousPrice * (1+matrix.get(_refMatrix, i, bar))
            previousPrice

boxChecks(_array, _upperBreakArray, _lowerBreakArray, _upperBreakHighArray, _lowerBreakHighArray, _upperBreakLowsArray, _lowerBreakLowsArray, _upperBreakMatrix, _lowerBreakMatrix, _upperBreakHighMatrix, _lowerBreakHighMatrix, _upperBreakLowsMatrix, _lowerBreakLowsMatrix, _projectionLength) =>
    signal = 0
    if array.size(_array) >= 1
        for i = array.size(_array) - 1 to 0 by 1
            currentBoxStats = array.get(_array, i)
            currentBox = currentBoxStats.boxDrawing
            boxTop = box.get_top(currentBox)
            boxBottom = box.get_bottom(currentBox)
            boxEndPoint = box.get_right(currentBox)
            if gatherData
                if bar_index == currentBoxStats.upperBreakPoint + _projectionLength
                    _projectionFill(_upperBreakArray, _projectionLength, boxTop)
                    _projectionHighFill(_upperBreakHighArray, _projectionLength, boxTop)
                    _projectionLowsFill(_upperBreakLowsArray, _projectionLength, boxTop)
                    _matrixPush(_upperBreakMatrix, maxStatsHistory, _upperBreakArray)
                    _matrixPush(_upperBreakHighMatrix, maxStatsHistory, _upperBreakHighArray)
                    _matrixPush(_upperBreakLowsMatrix, maxStatsHistory, _upperBreakLowsArray)
                if bar_index == currentBoxStats.lowerBreakPoint + _projectionLength
                    _projectionFill(_lowerBreakArray, _projectionLength, boxBottom)
                    _projectionHighFill(_lowerBreakHighArray, _projectionLength, boxBottom)
                    _projectionLowsFill(_lowerBreakLowsArray, _projectionLength, boxBottom)
                    _matrixPush(_lowerBreakMatrix, maxStatsHistory, _lowerBreakArray)
                    _matrixPush(_lowerBreakHighMatrix, maxStatsHistory, _lowerBreakHighArray)
                    _matrixPush(_lowerBreakLowsMatrix, maxStatsHistory, _lowerBreakLowsArray)
            if not currentBoxStats.stopLooking
                if bar_index > boxEndPoint + max_bars_breakout
                    array.set(_array, i, boxStats.new(true, currentBoxStats.upperBreakPoint, currentBoxStats.lowerBreakPoint, currentBoxStats.boxMedianSlope, currentBox))
                if na(currentBoxStats.upperBreakPoint) and high > boxTop and open < boxTop
                    signal := 1
                    label.new(x = bar_index, y = high, text = 'upperbreak', textcolor = bullLabelTextColor, color = bullLabelColor, size = size.tiny, style = label.style_label_down, force_overlay = true)
                    if onlyUseFirstBreak
                        array.set(_array, i, boxStats.new(true, bar_index, currentBoxStats.lowerBreakPoint, currentBoxStats.boxMedianSlope, currentBox))
                    else
                        array.set(_array, i, boxStats.new(currentBoxStats.stopLooking, bar_index, currentBoxStats.lowerBreakPoint, currentBoxStats.boxMedianSlope, currentBox))
                if na(currentBoxStats.lowerBreakPoint) and low < boxBottom and open > boxBottom
                    signal := -1
                    label.new(x = bar_index, y = low, text = 'lowerbreak', textcolor = bearLabelTextColor, color = bearLabelColor, size = size.tiny, style = label.style_label_up, force_overlay = true)
                    if onlyUseFirstBreak
                        array.set(_array, i, boxStats.new(true, currentBoxStats.upperBreakPoint, bar_index, currentBoxStats.boxMedianSlope, currentBox))
                    else
                        array.set(_array, i, boxStats.new(currentBoxStats.stopLooking, currentBoxStats.upperBreakPoint, bar_index, currentBoxStats.boxMedianSlope, currentBox))
                if not na(currentBoxStats.upperBreakPoint) and not na(currentBoxStats.lowerBreakPoint)
                    array.set(_array, i, boxStats.new(true, currentBoxStats.lowerBreakPoint, currentBoxStats.upperBreakPoint, currentBoxStats.boxMedianSlope, currentBox))
    [signal]

singlePolyProject(_refMatrix, int _matrixRow, _polyArray, _statsArray, _projectionLength, yStart, xStart, color, width) =>
    if _refMatrix.rows() >= 1
        if not na(_refMatrix.get(0, 1))
            var quickPoints = array.new<chart.point>(_projectionLength + 1)
            _projectionPointsFromMatrix(_refMatrix, _matrixRow, quickPoints, _projectionLength, xStart, yStart)
            polyline.delete(_polyArray.get(_matrixRow))
            _polyArray.set(_matrixRow, polyline.new(points = quickPoints, line_color = color, curved = false, line_width = width, force_overlay = true))
            _statsArray.set(0, matrix.rows(_refMatrix))

doublePolyShapeProject(_refMatrix, int _matrixRow, _refMatrix2, int _matrixRow2, _polyArray, pushToIndex, _projectionLength, yStart, xStart, color, fillcolor, width) =>
    if _refMatrix.rows()>=1 and _refMatrix2.rows()>=1
        if (not na(_refMatrix.get(0, 1))) and (not na(_refMatrix2.get(0, 1)))
            quickPoints = array.new<chart.point>(_projectionLength+1)
            quickPoints2 = array.new<chart.point>(_projectionLength+1)
            combined = array.new<chart.point>()
            _projectionPointsFromMatrix(_refMatrix, _matrixRow, quickPoints, _projectionLength, xStart, yStart)
            _projectionPointsFromMatrix(_refMatrix2, _matrixRow2, quickPoints2, _projectionLength, xStart, yStart)
            // Push topPts in forward order:
            for i = 0 to array.size(quickPoints)-1
                array.push(combined, array.get(quickPoints, i))
            // Push botPts in *reverse* order:
            for j = array.size(quickPoints2) - 1 to 0
                array.push(combined, array.get(quickPoints2, j))
            polyline.delete(_polyArray.get(pushToIndex))
            _polyArray.set(pushToIndex, polyline.new(points = combined, line_color = color, curved = false, line_width = width, force_overlay = true, fill_color=fillcolor))

singlePolyProjectFromArray(_refMatrix, _polyArray, _labelArray, pushToIndex, bar, _projectionLength, yStart, xStart, color, width) =>
    if _refMatrix.rows()>=1 and bar>=0
        if not na(_refMatrix.get(0, 1))
            quickPoints = array.new<chart.point>(_projectionLength+2)
            _getEquityArray(_refMatrix, quickPoints, bar, xStart, yStart)
            label.delete(_labelArray.get(pushToIndex))
            _labelArray.set(pushToIndex, label.new(point=array.get(quickPoints, quickPoints.size()-1), text=str.tostring(bar), textcolor=color, color=#00000000, style=label.style_label_left, size=size.tiny, force_overlay=true))
            polyline.delete(_polyArray.get(pushToIndex))
            _polyArray.set(pushToIndex, polyline.new(points = quickPoints, line_color = color, curved = false, line_width = width, force_overlay = true))

//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//> ----> Variable Calculations <----- //> °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
// Calculate MA + MA slope variables
basis = maType == 'SMA' ? ta.sma(src, length) : donchian(length)
bSlope = math.abs((basis - basis[slopePeriod]) / slopePeriod)
bSlopeBasis = ta.percentile_nearest_rank(bSlope, 200, 50)
upperSlope1 = bSlopeBasis + ta.stdev(bSlope, 50)
//Check if in a consolidation
var int consol_c = na
consol_c := nz(consol_c[1], 1)
consol_c := consol_c + 1
if bSlope > upperSlope1
    consol_c := 0
    consol_c
isConsolidating = consol_c >= cons_period

// Box creation
highestHigh = ta.highest(high, cons_period)
lowestLows = ta.lowest(low, cons_period)
if isConsolidating and not isConsolidating[1]
    boxHigh := highestHigh
    boxLows := lowestLows
    boxLows
if isConsolidating and not isConsolidating[1]
    boxSize = (boxHigh - boxLows) / math.avg(boxHigh, boxLows)
    if useATR ? boxHigh - boxLows < atr * tinyBoxPerc : boxSize < tinyBoxPerc / 100
        _arrayLoad(tinyBoxes, 5000, boxStats.new(false, na, na, upperSlope1, box.new(left = bar_index - cons_period, top = boxHigh, right = bar_index, bottom = boxLows, xloc = xloc.bar_index, bgcolor = tinyBox_bgC, border_color = tinyBox_C, border_width = tinyBox_Width, force_overlay = true)))

// Perform breakout checks and put results in a matrix containing all past price action after the breakouts
[signal] = boxChecks(tinyBoxes, tinyUpperBreakArray, tinyLowerBreakArray, tinyUpperBreakHighArray, tinyLowerBreakHighArray, tinyUpperBreakLowsArray, tinyLowerBreakLowsArray, tinyUpperBreakMatrix, tinyLowerBreakMatrix, tinyUpperBreakHighMatrix, tinyLowerBreakHighMatrix, tinyUpperBreakLowsMatrix, tinyLowerBreakLowsMatrix, projectionLength)

// Creating the color scheme for the equity simulation lines and push to a color array based on amount of simulations
var tinyUpperEquityColors = array.new<color>()
var tinyLowerEquityColors = array.new<color>()
if colorMethod=="tint" or colorMethod=="shade" or colorMethod=="tone"
    tinyUpperEquityColors := colorlab.tst_scheme(equityBull_C, simulationSize, colorMethod)
    tinyLowerEquityColors := colorlab.tst_scheme(equityBear_C, simulationSize, colorMethod)
if colorMethod=="lightness"
    tinyUpperEquityColors := colorlab.lsh_scheme(colour=equityBull_C, size=simulationSize, _type=colorMethod, topLevel=20, botLevel=80)
    tinyLowerEquityColors := colorlab.lsh_scheme(colour=equityBear_C, size=simulationSize, _type=colorMethod, topLevel=20, botLevel=80)
if colorMethod=="saturation"
    tinyUpperEquityColors := colorlab.lsh_scheme(colour=equityBull_C, size=simulationSize, _type=colorMethod, topLevel=90, botLevel=10)
    tinyLowerEquityColors := colorlab.lsh_scheme(colour=equityBear_C, size=simulationSize, _type=colorMethod, topLevel=90, botLevel=10)
if colorMethod=="hue"
    tinyUpperEquityColors := colorlab.lsh_scheme(colour=equityBull_C, size=simulationSize, _type=colorMethod)
    tinyLowerEquityColors := colorlab.lsh_scheme(colour=equityBear_C, size=simulationSize, _type=colorMethod)
if barstate.islast and gatherData // This will perform all calculations for the averages and extremes and put them in a new matrix used for final projections
    _matrixCalculationsToMatrix(tinyUpperBreakMatrix, tinyUpperFinalMatrix, projectionLength)
    _matrixCalculationsToMatrix(tinyLowerBreakMatrix, tinyLowerFinalMatrix, projectionLength)
    _matrixCalculationsToMatrix(tinyUpperBreakHighMatrix, tinyUpperFinalHighMatrix, projectionLength)
    _matrixCalculationsToMatrix(tinyLowerBreakHighMatrix, tinyLowerFinalHighMatrix, projectionLength)
    _matrixCalculationsToMatrix(tinyUpperBreakLowsMatrix, tinyUpperFinalLowsMatrix, projectionLength)
    _matrixCalculationsToMatrix(tinyLowerBreakLowsMatrix, tinyLowerFinalLowsMatrix, projectionLength)
if barstate.islast and gatherData
    if projectionType == "Averages Projection"
        if showTinyRangePolys
            doublePolyShapeProject(tinyUpperFinalMatrix, 2, tinyUpperFinalMatrix, 3, tinyUpperFinalPolys, 2, projectionLength, close, bar_index, tinyRangePolyBull_C, tinyRangePolyBullBg_C, 1)
            doublePolyShapeProject(tinyLowerFinalMatrix, 2, tinyLowerFinalMatrix, 3, tinyLowerFinalPolys, 2, projectionLength, close, bar_index, tinyRangePolyBear_C, tinyRangePolyBearBg_C, 1)
        if showExtremes
            // upper break max
            doublePolyShapeProject(tinyUpperFinalMatrix, 2, tinyUpperFinalHighMatrix, 2, tinyUpperFinalPolys, 5, projectionLength, close, bar_index, tinyRangePolyBull_C, tinyRangePolyBull_C, 1)
            doublePolyShapeProject(tinyUpperFinalMatrix, 3, tinyUpperFinalLowsMatrix, 3, tinyUpperFinalPolys, 6, projectionLength, close, bar_index, tinyRangePolyBull_C, tinyRangePolyBull_C, 1)
            doublePolyShapeProject(tinyLowerFinalMatrix, 2, tinyLowerFinalHighMatrix, 2, tinyLowerFinalPolys, 5, projectionLength, close, bar_index, tinyRangePolyBear_C, tinyRangePolyBear_C, 1)
            doublePolyShapeProject(tinyLowerFinalMatrix, 3, tinyLowerFinalLowsMatrix, 3, tinyLowerFinalPolys, 6, projectionLength, close, bar_index, tinyRangePolyBear_C, tinyRangePolyBear_C, 1)
        if tinyAvgMethod == "Arithmetic Average"
            singlePolyProject(tinyUpperFinalMatrix, 0, tinyUpperFinalPolys, upperFinalTableStats, projectionLength, close, bar_index, polyBullAverages_C, 2)
            singlePolyProject(tinyLowerFinalMatrix, 0, tinyLowerFinalPolys, lowerFinalTableStats, projectionLength, close, bar_index, polyBearAverages_C, 2)
        if tinyAvgMethod == "Mean"
            singlePolyProject(tinyUpperFinalMatrix, 1, tinyUpperFinalPolys, upperFinalTableStats, projectionLength, close, bar_index, polyBullAverages_C, 2)
            singlePolyProject(tinyLowerFinalMatrix, 1, tinyLowerFinalPolys, lowerFinalTableStats, projectionLength, close, bar_index, polyBearAverages_C, 2)
        if tinyAvgMethod == "Geometric Average"
            singlePolyProject(tinyUpperFinalMatrix, 4, tinyUpperFinalPolys, upperFinalTableStats, projectionLength, close, bar_index, polyBullAverages_C, 2)
            singlePolyProject(tinyLowerFinalMatrix, 4, tinyLowerFinalPolys, lowerFinalTableStats, projectionLength, close, bar_index, polyBearAverages_C, 2)
    if projectionType == "Equity Simulation"
        for i = minHoldingTime to maxHoldingTime
            singlePolyProjectFromArray(tinyUpperBreakMatrix, tinyUpperEquityPolys, tinyUpperEquityLabels, i-minHoldingTime, i, tinyUpperBreakMatrix.rows() - 1, close, bar_index, tinyUpperEquityColors.get(i), equityLine_Width)
            singlePolyProjectFromArray(tinyLowerBreakMatrix, tinyLowerEquityPolys, tinyLowerEquityLabels, i-minHoldingTime, i, tinyLowerBreakMatrix.rows() - 1, close, bar_index, tinyLowerEquityColors.get(i), equityLine_Width)

//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//> -----> Graphical Display <----- //> °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//> $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
BasisPlot = plot(basis, color = MAColor, linewidth = MAWidth, title = 'Kijun-Sen', force_overlay = true, editable=false)
plot(math.abs(bSlope), color = math.abs(bSlope)>upperSlope1 ? slopeColor : slopeBelowColor, style = plot.style_columns, editable=false) // Plot slope
plot(upperSlope1, color = upperSlopeColor, linewidth = 1, editable=false) // Plot slope upper boundary for range detection
// Force user in adopting color theme
barcolor(close>open ? bullBarColor : bearBarColor, editable=false)
bgcolor(bgColor, editable=false, force_overlay=true)
bgcolor(bgColor, offset=100, editable=false, force_overlay=true)
bgcolor(bgColor, offset=200, editable=false, force_overlay=true)
bgcolor(bgColor, offset=400, editable=false, force_overlay=true)
bgcolor(bgColor, offset=600, editable=false, force_overlay=true)
bgcolor(bgColor, editable=false, force_overlay=false)
bgcolor(bgColor, offset=100, editable=false, force_overlay=false)
bgcolor(bgColor, offset=200, editable=false, force_overlay=false)
bgcolor(bgColor, offset=400, editable=false, force_overlay=false)
bgcolor(bgColor, offset=600, editable=false, force_overlay=false)
// Show amount of breakouts that happened to make projections. (statistical significance)
var statsTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1, force_overlay=true)
if barstate.islast
    table.cell(table_id = statsTable, column = 0, row = 0, text = str.tostring(matrix.rows(tinyUpperBreakMatrix)) + " breakouts", bgcolor=bullLabelColor, text_color=bullLabelTextColor)
    table.cell(table_id = statsTable, column = 1, row = 0, text = str.tostring(matrix.rows(tinyLowerBreakMatrix)) + " breakouts", bgcolor=bearLabelColor, text_color=bearLabelTextColor)

//> $$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//> -----> Alerts <----- //> °°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//> $$$$$$$$$$$$$$$$$$$$ //> **************************************************************************************************************************************************************************************************************************************************************************************************************************************************
bgcolor(signal == 1 ? bullLabelColor : signal == -1 ? bearLabelColor : na, title = 'Breakout signals on bottom graph', editable=false)
alertcondition(signal == 1, title = 'Upper breakout')
alertcondition(signal == -1, title = 'Lower breakout')
