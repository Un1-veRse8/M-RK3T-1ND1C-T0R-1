// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© LuxAlgo

//@version=6
indicator('Multi Ranges Volume Distribution [LuxAlgo]','LuxAlgo - MRVD', overlay = true, max_lines_count = 500, max_boxes_count = 500, max_bars_back = 5000)
//---------------------------------------------------------------------------------------------------------------------}
//CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
GREEN               = #089981
RED                 = #F23645

TOTAL               = 'Total'
BUYSELL             = 'Buy & Sell'

STYLE_GROUP         = 'Style'

volumeDisplayInput  = input.string(     BUYSELL,'Volume Display',           options = [TOTAL,BUYSELL])
distanceInput       = input.int(        25,     'Distance between each box',maxval = 80, minval = 10)
periodAInput        = input.timeframe(  'M',    'Period A', inline = 'A')
rowsAInput          = input.int(        20,     'Rows',     inline = 'A',   maxval = 80, minval = 1)
periodBInput        = input.timeframe(  'W',    'Period B', inline = 'B')
rowsBInput          = input.int(        10,     'Rows',     inline = 'B',   maxval = 80, minval = 1)
periodCInput        = input.timeframe(  'D',    'Period C', inline = 'C')
rowsCInput          = input.int(        5,      'Rows',     inline = 'C',   maxval = 80, minval = 1)

bullishColorInput   = input.color(      GREEN,  '',         group = STYLE_GROUP, inline = 'colors')
bearishColorInput   = input.color(      RED,    '',         group = STYLE_GROUP, inline = 'colors')

//---------------------------------------------------------------------------------------------------------------------}
//DATA STRUCTURES & VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
type lines
    line top    = na
    line bottom = na
    line poc    = na

type distribution
    int timeframe
    int rows
    float top
    float bottom
    int topIndex
    int bottomIndex    
    int leftIndex
    int rightIndex    
    lines l_ines    
    bool display = true

var array<distribution> distributions   = array.new<distribution>(3,na)
var array<int> periods                  = array.from(timeframe.in_seconds(periodCInput), timeframe.in_seconds(periodBInput), timeframe.in_seconds(periodAInput))
var array<int> dataRows                 = array.from(rowsCInput,rowsBInput,rowsAInput)
var array<int> dataRowsSorted           = periods.sort_indices()
var bool tickMode                       = true
var float parsedMintick                 = 1.
var int maxLimitMap                     = 50000
var map<float,float> totalVolume	    = map.new<float,float>()
var map<float,float> buyingVolume	    = map.new<float,float>()

//---------------------------------------------------------------------------------------------------------------------}
//USER-DEFINED FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
getRange(period)=>
    var float max   = na
    var float min   = na
    var int maxX1   = na
    var int minX1   = na

    if timeframe.change(timeframe.from_seconds(period))
        max     := high
        min     := low        
        maxX1   := bar_index
        minX1   := bar_index
    else 
        max     := math.max(high, max)
        min     := math.min(low, min)        
        maxX1   := high == max ? bar_index : maxX1
        minX1   := low  == min ? bar_index : minX1

    [max, maxX1, min, minX1]

checkMaps() =>    
    if totalVolume.size() == maxLimitMap
        key = totalVolume.keys().first()
        totalVolume.remove(key)

    if buyingVolume.size() == maxLimitMap
        key = buyingVolume.keys().first()
        buyingVolume.remove(key)
		
enableTickMode() =>             
    ticks           = int(ta.atr(10) / syminfo.mintick) + 1
    averageTicks    = request.security(syminfo.tickerid,timeframe.from_seconds(periods.last()),ticks,lookahead = barmerge.lookahead_on)
    averageTicks    <= 5000

round(float value) => tickMode ? math.round_to_mintick(value) : int(value)
    
gatherData() =>
    if not na(volume)
        size            = int((high - low) / parsedMintick) + 1
        volumePerLevel  = syminfo.type == 'crypto' ? (volume / size) : int(volume / size)
        bullBar         = close >= open        
        parsedHigh      = round(high)     
        parsedLow       = round(low)
        reParsedMintick = round(parsedMintick)
        for price0 = parsedHigh to parsedLow by reParsedMintick
            price = round(price0)
            checkMaps()
            totalVolume.put(price,nz(totalVolume.get(price))+volumePerLevel)
            if bullBar
                buyingVolume.put(price,nz(buyingVolume.get(price))+volumePerLevel)

getVolume(float top, float bottom) =>
    float totalVolumeOutput     = 0
    float buyingVolumeOutput    = 0
    float parsedTop             = round(top)
    float parsedBottom          = round(bottom)
    
    for index = parsedBottom to parsedTop by parsedMintick
        dataTotal           = totalVolume.get(index)
        totalVolumeOutput   += not na(dataTotal) ? dataTotal : 0
        dataBuying          = buyingVolume.get(index)
        buyingVolumeOutput  += not na(dataBuying) ? dataBuying : 0

    [totalVolumeOutput,buyingVolumeOutput]

updateRows(distribution d_istribution) =>
    float maxVolume = 0    
    float bottom    = d_istribution.bottom

    for index = 0 to d_istribution.rows
        top                     = d_istribution.bottom + index/d_istribution.rows * (d_istribution.top - d_istribution.bottom)        
        [totalVol, buyingVol]   = getVolume(top,bottom)
        maxVolume               := math.max(maxVolume,totalVol)

        if maxVolume == totalVol
            d_istribution.l_ines.poc.set_y1(math.round_to_mintick(math.avg(top,bottom)))
            d_istribution.l_ines.poc.set_y2(math.round_to_mintick(math.avg(top,bottom)))

        if volumeDisplayInput == TOTAL
            background = color.from_gradient(math.round(100*buyingVol/totalVol),0,100,bearishColorInput,bullishColorInput)
            box.new(last_bar_index + d_istribution.leftIndex,top,last_bar_index + d_istribution.rightIndex,bottom,bgcolor = color.new(background, 10), border_color = na, text = str.tostring(totalVol, format.volume))
        else            
            box.new(last_bar_index + d_istribution.leftIndex, top, last_bar_index + math.round(0.5*(d_istribution.leftIndex + d_istribution.rightIndex)),   bottom,bgcolor = color.new(bullishColorInput, 80),  border_color = na, text = str.tostring(buyingVol, format.volume),           text_color = bullishColorInput)
            box.new(last_bar_index + math.round(0.5*(d_istribution.leftIndex + d_istribution.rightIndex)), top, last_bar_index + d_istribution.rightIndex,  bottom,bgcolor = color.new(bearishColorInput, 80),  border_color = na, text = str.tostring(totalVol - buyingVol, format.volume),text_color = bearishColorInput)

        line.new(last_bar_index + d_istribution.leftIndex,top,last_bar_index + d_istribution.rightIndex,top, color = chart.fg_color)        
        bottom := top

style(int index) =>
    switch index
        0 => line.style_dotted
        1 => line.style_dashed
        2 => line.style_solid

updateLines(int index, distribution d_istribution) =>    
    barIndex = math.min(d_istribution.topIndex,d_istribution.bottomIndex)

    if index == 2 or (index != 2 and distributions.get(index + 1).top != d_istribution.top)
        d_istribution.l_ines.top := line.new(barIndex,d_istribution.top,last_bar_index + d_istribution.rightIndex,d_istribution.top, color = chart.fg_color, style = style(index))
    
    if index == 2 or (index != 2 and distributions.get(index + 1).bottom != d_istribution.bottom)
        d_istribution.l_ines.bottom := line.new(barIndex,d_istribution.bottom,last_bar_index + d_istribution.rightIndex,d_istribution.bottom, color = chart.fg_color, style = style(index))

    d_istribution.l_ines.poc := line.new(barIndex,d_istribution.bottom,last_bar_index,d_istribution.bottom, color = RED, style = style(index))        

createDistributions() =>
    index0                          = 0
    timeframe0                      = periods.get(index0)
    rows0                           = dataRows.get(dataRowsSorted.get(index0))
    [max0, maxX10, min0, minX10]    = getRange(timeframe0)
    distributions.set(index0,distribution.new(timeframe0,rows0,max0,min0,maxX10,minX10,index0*2*distanceInput + distanceInput,index0*2*distanceInput + 2*distanceInput,lines.new()))
    
    index1                          = 1
    timeframe1                      = periods.get(index1)
    rows1                           = dataRows.get(dataRowsSorted.get(index1))
    [max1, maxX11, min1, minX11]    = getRange(timeframe1)
    distribution0                   = distributions.get(index0)
    distribution0.display           := max0 == max1 and min0 == min1 and rows0 == rows1 ? false : true
    distributions.set(index1,distribution.new(timeframe1,rows1,max1,min1,maxX11,minX11,index1*2*distanceInput + distanceInput,index1*2*distanceInput + 2*distanceInput,lines.new()))
    
    index2                          = 2
    timeframe2                      = periods.get(index2)
    rows2                           = dataRows.get(dataRowsSorted.get(index2))
    [max2, maxX12, min2, minX12]    = getRange(timeframe2)
    distribution1                   = distributions.get(index1)
    distribution1.display           := max1 == max2 and min1 == min2 and rows1 == rows2 ? false : true
    distributions.set(index2,distribution.new(timeframe2,rows2,max2,min2,maxX12,minX12,index2*2*distanceInput + distanceInput,index2*2*distanceInput + 2*distanceInput,lines.new()))

flushDrawings() =>
    for eachLine in line.all
        eachLine.delete()
    for eachBox in box.all
        eachBox.delete()

updateDistributions() =>
    flushDrawings()

    for [index,eachDistribution] in distributions
        if eachDistribution.display
            updateLines(index,eachDistribution)
            updateRows(eachDistribution)

//---------------------------------------------------------------------------------------------------------------------}
//MUTABLE VARIABLES & EXECUTION
//---------------------------------------------------------------------------------------------------------------------{
if barstate.isfirst    
    periods.sort()

executionWindow         = timenow   - periods.last() * 1100
insideExecutionWindow   = time      >= executionWindow

if insideExecutionWindow   
    
    if not insideExecutionWindow[1]
        tickMode        := enableTickMode()
        parsedMintick   := tickMode ? syminfo.mintick : 1

    gatherData()

    createDistributions()

    if barstate.islast
        updateDistributions()
        
//---------------------------------------------------------------------------------------------------------------------}