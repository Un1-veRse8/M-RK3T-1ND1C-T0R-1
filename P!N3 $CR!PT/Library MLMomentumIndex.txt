// This work is a variation of the original "Machine Learning Momentum Index (MLMI)" script by Zeiierman,
// licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (CC BY-NC-SA 4.0).
// You can find the original work at:
// https://www.tradingview.com/script/I2X9DE84-Machine-Learning-Momentum-Index-MLMI-Zeiierman/
//
// This variation is created by tkarolak and is also licensed under the CC BY-NC-SA 4.0 license.
// For more information about the CC BY-NC-SA 4.0 license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Â© 2024 tkarolak

//@version=5

// @description Enables market momentum analysis with k-NN predictions on pivot points, offering customizable parameters for dynamic trading strategies.
library("MLMomentumIndex", true)

// @type Represents a data structure used for storing and organizing trading data.
// @field parameter1 <array<float>> Stores the first set of parameter values for analysis or strategy application.
// @field parameter2 <array<float>> Stores the second set of parameter values for analysis or strategy application.
// @field parameter3 <array<float>> Stores the third set of parameter values for analysis or strategy application.
// @field parameter4 <array<float>> Stores the fourth set of parameter values for analysis or strategy application.
// @field priceArray <array<float>> Contains price data, such as closing prices, relevant to the trading strategy.
// @field resultArray <array<float>> Stores the outcomes or results of the trading strategy or analysis, such as profitability measures or calculated indicators.
type Data
    array<float>    parameter1
    array<float>    parameter2
    array<float>    parameter3
    array<float>    parameter4
    array<float>    priceArray
    array<float>    resultArray


// @function Rescales a value from one range to another.
// @param sourceSeries: The value to be rescaled.
// @param oldMin: The minimum of the old range.
// @param oldMax: The maximum of the old range.
// @param newMin: The minimum of the new range.
// @param newMax: The maximum of the new range.
// @returns The rescaled value.
rescale(series float sourceSeries, float oldMin, float oldMax, float newMin, float newMax) =>
    newMin + (newMax - newMin) * (sourceSeries - oldMin) / math.max(oldMax - oldMin, 10e-10)

// @function Detects pivot highs and lows within a given number of bars.
// @param pivotBars: The number of bars to analyze for pivot detection.
// @returns A tuple indicating the presence of pivot highs and lows.
detectPivots(int pivotBars) =>
    float ph = ta.pivothigh(pivotBars, pivotBars)
    float pl = ta.pivotlow(pivotBars, pivotBars)
    [not na(ph), not na(pl)]

// @function Stores the previous trade data in the Data object.
// @param d: The Data object to update.
// @param p1, p2, p3, p4: The parameters for the model input.
// @param price: The price associated with the trade.
// @param n: The maximum size of the data arrays.
// @returns void, shifts the oldest data out if the max size is exceeded.
method storePreviousTrade(Data d, float p1, float p2, float p3, float p4, float price, int n) =>
    int size = d.priceArray.size()
    float prevPrice = d.priceArray.last()
    d.parameter1.push(p1)
    d.parameter2.push(p2)
    d.parameter3.push(p3)
    d.parameter4.push(p4)
    d.priceArray.push(price)
    d.resultArray.push(price >= prevPrice ? 1 : -1)
    if size > n-1
        d.parameter1.shift()
        d.parameter2.shift()
        d.parameter3.shift()
        d.parameter4.shift()
        d.priceArray.shift()
        d.resultArray.shift()

// @functions Predicts future price movement using the k-nearest neighbors algorithm.
// @param d: The Data object containing historical data.
// @param p1, p2, p3, p4: The current parameters for the prediction.
// @param k: The number of nearest neighbors to consider.
// @returns The predicted movement direction, rescaled to the range [-100, 100].
method knnPredict(Data d, float p1, float p2, float p3, float p4, int k) =>
    // Create a Distance Array (Euclidean distance formula)
    distances = array.new_float(0)
    int n = d.parameter1.size() - 1
    for i = 0 to n
        float distance = math.sqrt(math.pow(p1 - d.parameter1.get(i), 2) + math.pow(p2 - d.parameter2.get(i), 2) + math.pow(p3 - d.parameter3.get(i), 2) + math.pow(p4 - d.parameter4.get(i), 2))
        distances.push(distance)
    sortedIndices = array.sort_indices(distances)
    neighbors = array.new_float()
    for i = 0 to k - 1
        array.push(neighbors, d.resultArray.get(sortedIndices.get(i)))
    // Return Prediction
    float prediction = neighbors.avg()
    float min = ta.lowest(prediction,2000)
    float max = ta.highest(prediction,2000)
    rescale(prediction,min,max,-100,100)

// @function Main function: Calculates momentum index from pivots and predicts future direction.
// @param source: Price series to analyze.
// @param pivotBars: Number of bars for pivot detection.
// @param momentumWindow: Window size for momentum calculation.
// @param maxData: Maximum number of data points to store.
// @param numNeighbors: Number of neighbors for k-NN prediction.
// @param predictionSmoothing: Smoothing period for the prediction result.
// @returns Tuple of raw and smoothed prediction values.
export momentumIndexPivots(series float source = close, int pivotBars = 20, int momentumWindow = 25, 
   int maxData = 500, int numNeighbors = 100, int predictionSmoothing =20) =>
    // Create a Data object
    var data = Data.new(array.new_float(numNeighbors, na), array.new_float(numNeighbors, na), array.new_float(numNeighbors, na), array.new_float(numNeighbors, na), array.new_float(numNeighbors, na), array.new_float(numNeighbors, na))
    float param1   = ta.wma(ta.rsi(source,12),momentumWindow)
    float param2   = ta.wma(ta.rsi(source, 25),momentumWindow)
    float param3   = ta.wma(ta.rsi(source, 50),momentumWindow)
    float param4   = ta.wma(ta.rsi(source, 100),momentumWindow)
    // Pivots Detection
    [phDetected,plDetected] = detectPivots(pivotBars)
    // Adding point to data set
    if phDetected or plDetected
        data.storePreviousTrade(param1[pivotBars], param2[pivotBars], param3[pivotBars], param4[pivotBars], source[pivotBars], maxData)
    // Predictions & its moving average (WMA)
    float prediction    = data.knnPredict(param1, param2, param3, param4, numNeighbors)
    float predictionMa = ta.wma(prediction, predictionSmoothing)
    [prediction,predictionMa]