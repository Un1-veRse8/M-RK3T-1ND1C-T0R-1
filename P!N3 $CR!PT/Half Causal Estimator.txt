// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © The_Peaceful_Lizard

//@version=6
indicator("Half Causal Estimator", format = format.volume)

// HEAD {

// enums and types {

enum Source
    vol = "Volume"
    tr = "True Range"
    change = "Change"

enum KernelType
    gaussian = "Gaussian"
    epanechnikov = "Epanechnikov"
    triangular = "Triangular"

type Key
    int m = minute
    int h = hour

type Vec
    float[] values

type Data
    Vec[] data
    bool[] valid

type Settings
    int data_period = 0
    int filter_length = 10
    int window_size = 20
    float kernel_width = 10
    KernelType kernel_type = KernelType.epanechnikov

// enums and types }

// make data {

init_data()=>
    var int size = 1440 / timeframe.multiplier
    var const Vec[] data = array.new<Vec>(size)
    var const bool[] valid = array.new<bool>(size, false)
    Data.new(data, valid)

key_to_hash(Key key)=>
    int hash = int((key.h * 60 + key.m) / timeframe.multiplier)
    hash

hash_now()=> 
    key_to_hash(Key.new())

advance_key(Key self, int forward)=>
    int advanced_minute = self.m + (forward * timeframe.multiplier)
    int      new_minute = advanced_minute % 60
    int      new_hour   = (self.h + int(advanced_minute / 60)) % 24
    Key.new(new_minute, new_hour)

method maintain(float[] self, int length)=>
    if length > 0 and self.size() >= length
        self.pop()

method add_pop(float[] self, float value, int length)=>
    self.maintain(length)
    self.unshift(value)

method add_element(Data self, float source, int length)=>
    Vec[] data = self.data
    bool[] valid = self.valid
    int idx = hash_now()
    if not na(source)
        if valid.get(idx)
            data.get(idx).values.add_pop(source, length)
        else
            data.set(idx, Vec.new(array.from(source)))
            valid.set(idx, true)

method get_average(Data self, Key key)=>
    float result = na
    int idx = key_to_hash(key)
    if self.valid.get(idx)
        result := self.data.get(idx).values.avg()
    result

relative(float source, Settings config)=>
    var Data data = init_data()
    data.add_element(source, config.data_period)
    data

// make data }

// filtering {

gaussian_kernel(float source, float bandwidth) => 
    float ratio = source / bandwidth
    math.exp(-math.pow(ratio, 2) / 2) / math.sqrt(2 * math.pi) 

epanechnikov_kernel(float source, float bandwidth) =>
    float ratio = source / bandwidth
    switch math.abs(ratio) <= 1
        true => (3 / 4.) * (1 - math.pow(ratio, 2))
        false => 0.0

triangular_kernel(float source, float bandwidth) =>
    float ratio = source / bandwidth
    switch math.abs(ratio) <= 1
        true => 1 - math.abs(ratio)
        false => 0.0

select_kernel(float source, Settings config)=>
    switch config.kernel_type
        KernelType.gaussian => gaussian_kernel(source, config.kernel_width)
        KernelType.epanechnikov => epanechnikov_kernel(source, config.kernel_width)
        KernelType.triangular => triangular_kernel(source, config.kernel_width)

kernel_coef(Settings config)=>
    var const matrix<float> coef = matrix.new<float>(1, config.window_size)
    float normalization = 0
    for i = 0 to config.window_size - 1
        float j = i - (config.window_size - 1) / 2
        float weight = select_kernel(j, config)
        normalization += weight
        coef.set(0, i, weight)
    coef.mult(1.0 / normalization)

filter(float[] window, matrix<float> kernel)=>
    kernel.mult(window).first()

// filtering }

// estimator {

method init_make_window(float[] self, Data data, int size, Key key_now)=>
    Key return_key = Key.new()
    self.clear()

    int idx = 1
    while self.size() < size
        Key key = advance_key(key_now, idx)
        if data.valid.get(key_to_hash(key))
            return_key := key
            float value = data.get_average(key)
            self.unshift(value)
        idx += 1
    return_key

method maintain_window(float[] self, Key window_key, Data data)=>
    Key key_now = window_key
    Key return_key = window_key
    int size = self.size()

    self.pop()
    int idx = 1 
    while self.size() < size
        Key key = advance_key(key_now, idx)
        if data.valid.get(key_to_hash(key))
            return_key := key
            float value = data.get_average(key)
            self.unshift(value)
        idx += 1
    return_key

make_window(float source, Data data, bool ready, Settings config)=>
    var Key window_key = Key.new()
    var const float[] buffer = array.new<float>()
    var const float[] ahead = array.new<float>()
    
    Key key_now = Key.new()
    buffer.add_pop(source, config.filter_length)

    bool update = session.isfirstbar or session.isfirstbar_regular
    if ready
        if update
            window_key := ahead.init_make_window(data, config.filter_length - 1, key_now)
        else
            window_key := ahead.maintain_window(window_key, data)
    float[] window = ahead.copy().concat(buffer)
    window

make_smooth(float[] window, bool ready, Settings config)=>
    float smooth = na
    var const matrix<float> kernel = kernel_coef(config)
    if ready
        smooth := filter(window, kernel)
    smooth

// estimator }

// main {

ready(Settings config)=>
    var bool ready = false
    if not ready and bar_index > (config.window_size) and session.isfirstbar
        ready := true
    ready

main(float source, Settings config)=>
    bool ready = ready(config)
    var Data data = init_data()
    float[] window = make_window(source, data, ready, config)
    float smooth = make_smooth(window, ready, config)
    data.add_element(source, config.data_period)
    smooth

// main }

// HEAD }


// BODY {

// inputs {

const string estimator_group = "Estimator Settings"

const string source_tip = "Volume: This source utilizes the symbols volume. \n
 \nTR: True range for the symbol expressed as a percent. \n
 \nChange: The percent change from one close to the next." 

const string period_tip = "This is the number of days worth of observations to store for the estimate. A value of 0
 will use all available observations."

const string length_tip = "This is the number of historical data points for the filter. The actual size of the filter
 is length * 2 - 1 as half of the window is future points."

const string width_tip = "This controls the width of the filter. Generally you will want it to be the same as your
 length, but you can adjust it to be any size. A value larger than the length will make the kernel larger than the set,
 while a number smaller than the length will effectivly make the filter the size of the width."

var Source data_source = input.enum(Source.vol, "Source", tooltip = source_tip, group = estimator_group)
int data_period = input.int(5, "Data Period", minval = 0, tooltip = period_tip, group = estimator_group)
int filter_length = input.int(20, "Filter Length", minval = 2, tooltip = length_tip, group = estimator_group)
float kernel_width = input.float(20, "Filter Width", minval = 0.125, step = 0.125, tooltip = width_tip, group = estimator_group)
var KernelType kernel_type = input.enum(KernelType.epanechnikov, "Kernel Type", group = estimator_group)

const string visual_group = "Visual Settings"
color estimator_color = input.color(#FEFEFE, "Estimator Color", group = visual_group)
color bullish_color = input.color(#089981, "Bullish Color", group = visual_group)
color bearish_color = input.color(#f23645, "Bearish Color", group = visual_group)
int line_width = input.int(2, "Line Width", minval = 1, group = visual_group)

var Settings config = Settings.new(
   data_period
 , filter_length
 , filter_length * 2 - 1 
 , kernel_width
 , kernel_type
 )

// inputs }

// calculations {

float source = switch data_source
    Source.vol => volume
    Source.tr => (high - low) / low * 100
    Source.change => math.abs(close - nz(close[1], close)) / math.min(close, nz(close[1], close)) * 100

float estimate = main(source, config)

color colour = switch data_source
    Source.change => close > close[1] ? bullish_color: bearish_color
    => open < close ? bullish_color : bearish_color

// calculations }

// plot {

show_volume = data_source == Source.vol ? display.all : display.none
show_percent = data_source != Source.vol ? display.all : display.none

plot(source, "Volume", colour, 1, plot.style_columns, format = format.volume, display = show_volume)
plot(estimate, "Volume Average", estimator_color, line_width, format = format.volume, display = show_volume)

plot(source, "Volume", colour, 1, plot.style_columns, format = format.percent, display = show_percent)
plot(estimate, "Volume Average", estimator_color, line_width, format = format.percent, display = show_percent)

// plot }

// errors {

float has_volume = ta.cum(volume)

if barstate.isfirst
    if not timeframe.isminutes
        runtime.error("Timeframe must be minute/s intraday.")

if barstate.islast
    if has_volume == 0
        runtime.error("To use volume, the symbol must have volume.")

// errors }

// BODY }
