// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Tradenometry

//@version=5
indicator("Square-root Decay Volume Profile", overlay=true, max_boxes_count=500)

// ─ Inputs ───────────────────────────────────────────────────────────
lookback    = input.int(100,  "Lookback Period",    minval=1)
bin_count   = input.int(30,   "Number of Bins",     minval=1)
price_src   = input.source(close, "Price Source")
hist_length = input.int(20,   "Histogram Width\n(in bars)", minval=1)

// ─ Calc Range & Bin Height with guard ──────────────────────────────
lowP  = ta.lowest(price_src, lookback)
highP = ta.highest(price_src, lookback)
// only compute binH when there's a non-zero range and at least one bin
binH  = (highP > lowP and bin_count > 0) ? (highP - lowP) / bin_count : na

// ─ Persistent Storage ──────────────────────────────────────────────
var float[] weights = array.new_float(bin_count, 0.0)
var box[]   boxes   = array.new_box()  // starts empty

// ─ Recompute √-decay weights each bar ──────────────────────────────
if bar_index > lookback and not na(binH)
    // zero out
    for i = 0 to bin_count - 1
        array.set(weights, i, 0.0)
    // accumulate 1/√i for i = 1 … lookback, guarding denom≠0
    for i = 1 to lookback
        p     = price_src[i]
        denom = math.sqrt(i)
        w     = denom != 0.0 ? 1.0 / denom : 0.0
        idx   = math.floor((p - lowP) / binH)
        idx   := math.max(0, math.min(idx, bin_count - 1))
        array.set(weights, idx, array.get(weights, idx) + w)

// ─ On the last bar: cleanup old boxes & draw new profile ───────────
if barstate.islast and not na(binH)
    // only delete if we have any boxes
    if array.size(boxes) > 0
        for j = 0 to array.size(boxes) - 1
            box.delete(array.get(boxes, j))
        array.clear(boxes)
    // find max weight for normalization
    maxW = 0.0
    for i = 0 to bin_count - 1
        maxW := math.max(maxW, array.get(weights, i))
    // draw each bin as a box extending into future bars
    for i = 0 to bin_count - 1
        y    = lowP + (i + 0.5) * binH
        w    = array.get(weights, i)
        norm = maxW != 0.0 ? w / maxW : 0.0
        segW = int(norm * hist_length)
        if segW > 0
            b = box.new(bar_index, y - binH * 0.5,bar_index + segW, y + binH * 0.5,border_width=0, bgcolor=color.new(color.teal, 80),xloc=xloc.bar_index)
            array.push(boxes, b)
