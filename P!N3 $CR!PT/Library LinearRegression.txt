// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © TanHef

//@version=6

// @description Calculates a variety of linear regression and deviation types, with optional emphasis weighting. Additionally, multiple of slope and Pearson’s R calculations.

library('LinearRegression')

// Calculate Slope
// @function                Calculates the slope of a linear regression over the specified length.
// @param _src              (float) The source data.
// @param _len              (int) The length of the lookback period for the linear regression.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast for efficiency.
// @returns                 (float) The slope of the linear regression.
export calcSlope(float _src, int _len, bool _condition) =>
    if _condition and _len >= 2
        sumX = 0.0
        sumY = 0.0
        sumXY = 0.0
        sumXX = 0.0
        for j = 0 to _len - 1 by 1
            x = j
            y = _src[j]
            sumX := sumX + x
            sumY := sumY + y
            sumXY := sumXY + x * y
            sumXX := sumXX + x * x
            sumXX
        slope = -(_len * sumXY - sumX * sumY) / (_len * sumXX - sumX * sumX)
        slope

// @function                Calculates a basic linear regression, returning y1, y2, slope, and average.
// @param _src              (float) The source data series.
// @param _len              (int) The length of the lookback period.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 (float[]) An array of 4 values: [y1, y2, slope, average].
export calcReg(float _src, int _len, bool _condition) =>
    if _condition
        float avgSum = 0.0
        for int i = 1 to _len by 1
            avgSum := avgSum + _src[i - 1]
            avgSum
        float average = avgSum / _len
        float sumX = 0.0
        float sumY = 0.0
        float sumXY = 0.0
        float sumXX = 0.0
        for j = 0 to _len - 1 by 1
            int x = j
            float y = _src[j]
            sumX := sumX + x
            sumY := sumY + y
            sumXY := sumXY + x * y
            sumXX := sumXX + x * x
            sumXX
        int n = _len
        float slope = -(_len * sumXY - sumX * sumY) / (_len * sumXX - sumX * sumX)
        float y1 = average - slope * math.floor(_len / 2) + (1 - _len % 2) / 2 * slope
        float y2 = y1 + slope * (_len - 1)
        [y1, y2, slope, average]
    else
        [float(na), float(na), float(na), float(na)]

// @function                Calculates an Standard linear regression with optional emphasis.
// @param _src              (series float) The source data series.
// @param _len              (int) The length of the lookback period.
// @param _emphasis         (float) The emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 (float[]) [y1, y2, slope, weighted_average].
export calcRegStandard(series float _src, int _len, float _emphasis = 0, bool _condition = true) =>
    if _condition
        // Calculate EMA-style emphasis
        float emphasis = _emphasis-1
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasis)
        if alpha > 1.0
            alpha := 1.0
        // Initialize weighted sums
        float sum_w = 0.0
        float sum_w_x = 0.0
        float sum_w_y = 0.0
        float sum_w_xy = 0.0
        float sum_w_xx = 0.0
        // Compute weighted sums over the lookback period
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)  // EMA-style weights
            float x = float(j)                // x increases backward in time
            float y = _src[j]                 // Source value at offset j
            sum_w += w
            sum_w_x += w * x
            sum_w_y += w * y
            sum_w_xy += w * x * y
            sum_w_xx += w * x * x
        // Calculate slope using weighted least squares
        float b = (sum_w_xy - sum_w_x * sum_w_y / sum_w) / (sum_w_xx - math.pow(sum_w_x, 2) / sum_w)
        float slope = -b  // Negate to make slope positive for rising trends
        // Compute weighted average
        float weighted_average = sum_w_y / sum_w
        // Calculate y1 and y2 to match typical regression output
        float y1 = weighted_average - slope * math.floor(_len / 2) + (1 - _len % 2) / 2.0 * slope
        float y2 = y1 + slope * (_len - 1)
        [y1, y2, slope, weighted_average]
    else
        [float(na), float(na), float(na), float(na)]

// @function                Calculates a ridge regression with optional emphasis.
// @param _src              (float) The source data series.
// @param _len              (int) The length of the lookback period.
// @param lambda            (float) The ridge regularization parameter.
// @param _emphasis         (float) The emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 (float[]) [intercept, y2, slope, average].
export calcRegRidge(float _src, int _len, float lambda = 1.0, float _emphasis = 0, bool _condition = true) =>
    if _condition
        // Calculate EMA-style emphasis
        float emphasisAdj = _emphasis - 1.0
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasisAdj)
        if alpha > 1.0
            alpha := 1.0
        // Initialize weighted sums
        float sumW   = 0.0
        float sumX   = 0.0
        float sumY   = 0.0
        float sumXY  = 0.0
        float sumXX  = 0.0
        // Compute weighted sums over the lookback period.
        // If alpha is 0 (emphasis=0), then math.pow(1 - 0, j) == 1 for every j.
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            float x = float(j)
            float y = _src[j]
            sumW   += w
            sumX   += w * x
            sumY   += w * y
            sumXY  += w * x * y
            sumXX  += w * x * x
        // Compute the weighted (or unweighted when emphasis=0) average:
        float average = sumY / sumW
        // Apply the ridge regression formula using the weighted sums.
        float ridgeSlope = -(sumW * sumXY - sumX * sumY) / (sumW * (sumXX + lambda) - math.pow(sumX, 2))
        float intercept = (sumY - ridgeSlope * sumX) / sumW
        float y1 = average - ridgeSlope * math.floor(_len / 2) + (1 - _len % 2) / 2.0 * ridgeSlope
        float y2 = y1 + ridgeSlope * (_len - 1)
        [intercept, y2, ridgeSlope, average]
    else
        [na, na, na, na]

// @function                Calculates a Lasso regression with optional emphasis.
// @param _src              (float) The source data series.
// @param _len              (int) The length of the lookback period.
// @param lambda            (float) The Lasso regularization parameter.
// @param _emphasis         (float) The emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 (float[]) [intercept, (intercept + slope*(_len-1)), slope, average].
export calcRegLasso(float _src, int _len, float lambda, float _emphasis = 0, bool _condition = true) =>
    if _condition
        // Calculate EMA-style emphasis
        float emphasisAdj = _emphasis - 1.0
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasisAdj)
        if alpha > 1.0
            alpha := 1.0  // Clamp alpha to not exceed 1.
        // Compute weighted sums for average and weighted mean of x and y:
        float sumW = 0.0
        float sumWX = 0.0
        float sumWY = 0.0
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            sumW  += w
            sumWX += w * j
            sumWY += w * _src[j]
        float average = sumWY / sumW
        float meanX = sumWX / sumW
        float meanY = average
        // Compute weighted numerator and denominator for centered OLS slope:
        float num = 0.0
        float den = 0.0
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            float x = j
            float y = _src[j]
            num += w * (x - meanX) * (y - meanY)
            den += w * math.pow(x - meanX, 2)
        float slopeOLS = -num / den
        // Apply soft-thresholding for Lasso:
        float lassoSlope = math.sign(slopeOLS) * math.max(math.abs(slopeOLS) - lambda, 0)
        float intercept = meanY - lassoSlope * meanX
        [intercept, intercept + lassoSlope * (_len - 1), lassoSlope, average]
    else
        [na, na, na, na]

// @function                Calculates an Elastic Net regression with optional emphasis.
// @param _src              (float) The source data series.
// @param _len              (int) The length of the lookback period.
// @param lambda1           (float) L1 regularization parameter (Lasso).
// @param lambda2           (float) L2 regularization parameter (Ridge).
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 (float[]) [intercept, (intercept + beta*(_len-1)), beta, average].
export calcElasticNetLinReg(float _src, int _len, float lambda1, float lambda2, float _emphasis = 0, bool _condition = true) =>
    if _condition
        // Calculate EMA-style emphasis
        float emphasisAdj = _emphasis - 1.0
        float alpha = 2.0/(_len+1) * (1.0 + emphasisAdj)
        if alpha > 1.0
            alpha := 1.0
        // Compute weighted sums for average, meanX, and meanY.
        float sumW   = 0.0
        float sumWX  = 0.0
        float sumWY  = 0.0
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            sumW  += w
            sumWX += w * j
            sumWY += w * _src[j]
        float average = sumWY / sumW
        float meanX   = sumWX / sumW
        float meanY   = average
        // Compute weighted, centered sums:
        float S = 0.0
        float T = 0.0
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            float x = j - meanX
            float y = _src[j] - meanY
            S += w * x * y
            T += w * x * x
        float beta = (T != 0) ? -(math.sign(S) * math.max(math.abs(S) - lambda1, 0)) / (T + lambda2) : 0.0
        float intercept = meanY - beta * meanX
        [intercept, intercept + beta * (_len - 1), beta, average]
    else
        [na, na, na, na]

// @function                Calculates a Huber regression using Iteratively Reweighted Least Squares (IRLS).
// @param _src              (float) The source data series.
// @param _len              (int) The length of the lookback period.
// @param delta             (float) Huber threshold parameter.
// @param iterations        (int) Number of IRLS iterations.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 (float[]) [intercept, (intercept + slope*(_len-1)), slope, average].
export calcRegHuber(float _src, int _len, float delta, int iterations, float _emphasis = 0, bool _condition = true) =>
    if _condition
        // Calculate EMA-style emphasis
        float emphasisAdj = _emphasis - 1.0
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasisAdj)
        if alpha > 1.0
            alpha := 1.0
        // Compute weighted average of _src using EMA weights.
        float sumW = 0.0
        float avgSum = 0.0
        for j = 0 to _len - 1
            float wEm = math.pow(1 - alpha, j)  // EMA weight: if alpha==0 then wEm==1
            avgSum += wEm * _src[j]
            sumW += wEm
        float average = avgSum / sumW
        // Compute initial weighted sums for OLS estimates:
        float sumX  = 0.0
        float sumY  = 0.0
        float sumXY = 0.0
        float sumXX = 0.0
        for j = 0 to _len - 1
            float wEm = math.pow(1 - alpha, j)
            float x = j
            float y = _src[j]
            sumX  += wEm * x
            sumY  += wEm * y
            sumXY += wEm * x * y
            sumXX += wEm * x * x
        // Use the sum of weights (sumW) in place of n.
        float slope = -(sumW * sumXY - sumX * sumY) / (sumW * sumXX - math.pow(sumX, 2))
        float intercept = (sumY - slope * sumX) / sumW
        // IRLS loop with combined Huber and EMA weights:
        for it = 0 to iterations - 1
            float wSum = 0.0
            float wX   = 0.0
            float wY   = 0.0
            float wXY  = 0.0
            float wXX  = 0.0
            for j = 0 to _len - 1
                float wEm = math.pow(1 - alpha, j)
                float x = j
                float y = _src[j]
                // Calculate residual:
                float r = y - (intercept + slope * x)
                // Huber weight:
                float wHuber = (math.abs(r) <= delta) ? 1.0 : delta / math.abs(r)
                // Combined weight:
                float w = wEm * wHuber
                wSum  += w
                wX    += w * x
                wY    += w * y
                wXY   += w * x * y
                wXX   += w * x * x
            slope := -(wSum * wXY - wX * wY) / (wSum * wXX - math.pow(wX, 2))
            intercept := (wY - slope * wX) / wSum
        [intercept, intercept + slope * (_len - 1), slope, average]
    else
        [na, na, na, na]

// @function                Calculates a Least Absolute Deviations (LAD) regression via IRLS.
// @param _src              (float) The source data series.
// @param _len              (int) The length of the lookback period.
// @param iterations        (int) Number of IRLS iterations for LAD.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 (float[]) [intercept, (intercept + slope*(_len-1)), slope, average].
export calcRegLAD(float _src, int _len, int iterations, float _emphasis = 0, bool _condition = true) =>
    if _condition
        float epsilon = 1e-6
        // Calculate EMA-style emphasis
        float emphasisAdj = _emphasis - 1.0
        float alpha = 2.0/(_len+1) * (1.0 + emphasisAdj)
        if alpha > 1.0
            alpha := 1.0
        // Compute weighted average of _src.
        float sumW  = 0.0
        float sumWY = 0.0
        float sumWX = 0.0
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            sumW  += w
            sumWY += w * _src[j]
            sumWX += w * j
        float average = sumWY / sumW
        float meanX   = sumWX / sumW
        float meanY   = average
        // Initialize using weighted OLS.
        float num = 0.0
        float den = 0.0
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            float x = j
            float y = _src[j]
            num += w * (x - meanX) * (y - meanY)
            den += w * math.pow(x - meanX, 2)
        float beta = (den != 0) ? num/den : 0.0
        float intercept = meanY - beta * meanX
        // IRLS loop for LAD.
        for it = 0 to iterations - 1
            float wSum = 0.0
            float wX   = 0.0
            float wY   = 0.0
            float wXX  = 0.0
            float wXY  = 0.0
            for j = 0 to _len - 1
                float wEm = math.pow(1 - alpha, j)
                float x = j
                float y = _src[j]
                float r = y - (intercept + beta * x)
                float wLAD = 1.0 / (math.abs(r) + epsilon)
                float w = wEm * wLAD
                wSum += w
                wX   += w * x
                wY   += w * y
                wXX  += w * x * x
                wXY  += w * x * y
            beta := -(wSum * wXY - wX * wY) / (wSum * wXX - math.pow(wX, 2))
            intercept := (wY - beta * wX) / wSum
        [intercept, intercept + beta * (_len - 1), beta, average]
    else
        [na, na, na, na]

// @function                Calculates a Bayesian linear regression with optional emphasis.
// @param _src              (float) The source data series.
// @param _len              (int) The length of the lookback period.
// @param priorMean         (float) The prior mean for the slope.
// @param priorSpan         (float) The prior variance (or span) for the slope.
// @param sigma             (float) The assumed standard deviation of residuals.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 (float[]) [intercept, (intercept + bayesSlope*(_len-1)), bayesSlope, average].
export calcRegBayesian(float _src, int _len, float priorMean, float priorSpan, float sigma, float _emphasis = 0, bool _condition = true) =>
    if _condition
        // Calculate EMA-style emphasis
        float emphasisAdj = _emphasis - 1.0
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasisAdj)
        if alpha > 1.0
            alpha := 1.0
        // Compute weighted arithmetic average of _src.
        float sumW = 0.0
        float weightedSrcSum = 0.0
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            weightedSrcSum += w * _src[j]
            sumW += w
        float average = weightedSrcSum / sumW
        // Compute weighted sums for x and y to get weighted means.
        float sumWX = 0.0
        float sumWY = 0.0
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            sumWX += w * j
            sumWY += w * _src[j]
        float meanX = sumWX / sumW
        float meanY = sumWY / sumW
        // Compute weighted numerator and denominator for centered OLS slope.
        float num = 0.0
        float den = 0.0
        for j = 0 to _len - 1
            float w = math.pow(1 - alpha, j)
            float x = j
            float y = _src[j]
            num += w * (x - meanX) * (y - meanY)
            den += w * math.pow(x - meanX, 2)
        float slopeOLS = num / den
        // Bayesian update for slope.
        float prec_data = den / (sigma * sigma)
        float prec_prior = 1.0 / priorSpan
        float bayesSlope = -(prec_data * slopeOLS + prec_prior * priorMean) / (prec_data + prec_prior)
        float intercept = meanY - bayesSlope * meanX

        [intercept, intercept + bayesSlope * (_len - 1), bayesSlope, average]
    else
        [na, na, na, na]

// Calculate Pearson Correlation Coefficient (R) from Linear Regression Parameters
// @function                Calculates the Pearson correlation coefficient (R) based on linear regression parameters.
// @param _src              (float) The source data.
// @param _len              (int) The length of the lookback period.
// @param _slope            (float) The slope of the linear regression.
// @param _average          (float) The average value of the source data series.
// @param _y1               (float) The starting point (y-intercept of the oldest bar) for the linear regression.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast for efficiency.
// @returns                 (float) The Pearson correlation coefficient (R) adjusted for the direction of the slope.
export calcRFromLinReg(float _src, int _len, float _slope, float _average, float _y1, bool _condition) =>
    if _condition and _len >= 2
        float sumSquaredDifferencesX = 0.0
        float sumSquaredDifferencesY = 0.0
        float sumProductDifferencesXY = 0.0
        int periods = _len - 1
        float adjustedMeanY = _y1 + _slope * periods / 2
        float currentValue = _y1
        for j = 0 to periods by 1
            float price = _src[j]
            float differenceX = price - _average
            float differenceY = currentValue - adjustedMeanY
            sumSquaredDifferencesX := sumSquaredDifferencesX + differenceX * differenceX
            sumSquaredDifferencesY := sumSquaredDifferencesY + differenceY * differenceY
            sumProductDifferencesXY := sumProductDifferencesXY + differenceX * differenceY
            currentValue := currentValue + _slope
            currentValue
        float pearsonR = sumSquaredDifferencesX == 0 or sumSquaredDifferencesY == 0 ? 0 : sumProductDifferencesXY / math.sqrt(sumSquaredDifferencesX * sumSquaredDifferencesY)
        pearsonR := _slope > 0 ? pearsonR * -1 : pearsonR // Adjust R to match the direction of the slope of correlation
        pearsonR

// Calculate Pearson Correlation Coefficient (R) from given length and source
// @function                Calculates the correlation coefficient (R) using a specified length and source data.
// @param _src              (float) The source data.
// @param _len              (int) The length of the lookback period.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast for efficiency.
// @returns                 (float) The correlation coefficient (R).
export calcRFromSource(float _src, int _len, bool _condition) =>
    if _condition and _len >= 2
        float avgSum = 0.0
        for int i = 1 to _len by 1
            avgSum := avgSum + _src[i - 1]
            avgSum
        float average = avgSum / _len
        float sumX = 0.0
        float sumY = 0.0
        float sumXY = 0.0
        float sumXX = 0.0
        for j = 0 to _len - 1 by 1
            int x = j
            float y = _src[j]
            sumX := sumX + x
            sumY := sumY + y
            sumXY := sumXY + x * y
            sumXX := sumXX + x * x
            sumXX
        float slope = -(_len * sumXY - sumX * sumY) / (_len * sumXX - sumX * sumX)
        float y1 = average - slope * math.floor(_len / 2) + (1 - _len % 2) / 2 * slope
        float intercept = y1 + slope * (_len - 1)
        float dsxx = 0.0
        float dsyy = 0.0
        float dsxy = 0.0
        int periods = _len - 1
        float daY = intercept + slope * periods / 2
        float val = intercept
        for j = 0 to periods by 1
            float price = _src[j]
            float dxt = price - average
            float dyt = val - daY
            dsxx := dsxx + dxt * dxt
            dsyy := dsyy + dyt * dyt
            dsxy := dsxy + dxt * dyt
            val := val + slope
            val
        float R = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
        R := slope > 0 ? R * -1 : R
        R

// Calculate Slope Length with Zero Bias
// @function                Identifies the length at which the slope is flattest (closest to zero).
// @param _src              (float) The source data.
// @param _len              (int) The maximum lookback length to consider (minimum of 2).
// @param _minLen           (int) The minimum length to start from (cannot exceed the max length).
// @param _step             (int) The increment step for lengths.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast.
// @returns                 (int) The length at which the slope is flattest.
export calcSlopeLengthZero(float _src, int _len, int _minLen, int _step, bool _condition) =>
    if _condition and _len >= 2
        float Slope_Flattest = 10000.0
        int Length_Flattest = 0
        for i = _minLen > _len ? 2 : _minLen - 1 to _len - 1 by _step
            float sumX = 0.0
            float sumY = 0.0
            float sumXY = 0.0
            float sumXX = 0.0
            for j = 0 to i - 1 by 1
                int x = j
                float y = _src[j]
                sumX := sumX + x
                sumY := sumY + y
                sumXY := sumXY + x * y
                sumXX := sumXX + x * x
                sumXX
            float slope = -(i * sumXY - sumX * sumY) / (i * sumXX - sumX * sumX)
            if math.abs(slope) < math.abs(Slope_Flattest)
                Slope_Flattest := slope
                Length_Flattest := i
                Length_Flattest
        Length_Flattest + 1

// Calculate Slope Length with Highest Value
// @function                Identifies the length at which the slope is highest.
// @param _src              (float) The source data.
// @param _len              (int) The maximum lookback length (minimum of 2).
// @param _minLen           (int) The minimum length to start from.
// @param _step             (int) The step for incrementing lengths.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast.
// @returns                 (int) The length at which the slope is highest.
export calcSlopeLengthHighest(float _src, int _len, int _minLen, int _step, bool _condition) =>
    if _condition and _len >= 2
        float Slope_Highest = -10000
        int Length_Highest = 0
        for i = _minLen > _len ? 2 : _minLen - 1 to _len - 1 by _step
            float sumX = 0.0
            float sumY = 0.0
            float sumXY = 0.0
            float sumXX = 0.0
            for j = 0 to i - 1 by 1
                int x = j
                float y = _src[j]
                sumX := sumX + x
                sumY := sumY + y
                sumXY := sumXY + x * y
                sumXX := sumXX + x * x
                sumXX
            float slope = -(i * sumXY - sumX * sumY) / (i * sumXX - sumX * sumX)
            if slope > Slope_Highest
                Slope_Highest := slope
                Length_Highest := i
                Length_Highest
        Length_Highest + 1

// Calculate Slope Length with Lowest Value
// @function                Identifies the length at which the slope is lowest.
// @param _src              (float) The source data.
// @param _len              (int) The maximum lookback length (minimum of 2).
// @param _minLen           (int) The minimum length to start from.
// @param _step             (int) The step for incrementing lengths.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast.
// @returns                 (int) The length at which the slope is lowest.
export calcSlopeLengthLowest(float _src, int _len, int _minLen, int _step, bool _condition) =>
    if _condition and _len >= 2
        float Slope_Lowest = 10000
        int Length_Lowest = 0
        for i = _minLen > _len ? 2 : _minLen - 1 to _len - 1 by _step
            float sumX = 0.0
            float sumY = 0.0
            float sumXY = 0.0
            float sumXX = 0.0
            for j = 0 to i - 1 by 1
                int x = j
                float y = _src[j]
                sumX := sumX + x
                sumY := sumY + y
                sumXY := sumXY + x * y
                sumXX := sumXX + x * x
                sumXX
            float slope = -(i * sumXY - sumX * sumY) / (i * sumXX - sumX * sumX)
            if slope < Slope_Lowest
                Slope_Lowest := slope
                Length_Lowest := i
                Length_Lowest
        Length_Lowest + 1

// Calculate Slope Length with Highest Absolute Value
// @function                Identifies the length at which the absolute slope value is highest.
// @param _src              (float) The source data.
// @param _len              (int) The maximum lookback length (minimum of 2).
// @param _minLen           (int) The minimum length to start from.
// @param _step             (int) The step for incrementing lengths.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast.
// @returns                 (int) The length at which the absolute slope value is highest.
export calcSlopeLengthAbsolute(float _src, int _len, int _minLen, int _step, bool _condition) =>
    if _condition and _len >= 2
        float Slope_Absolute = 0 // R Target
        int Length_Absolute = 0
        for i = _minLen > _len ? 2 : _minLen - 1 to _len - 1 by _step
            float sumX = 0.0
            float sumY = 0.0
            float sumXY = 0.0
            float sumXX = 0.0
            for j = 0 to i - 1 by 1
                int x = j
                float y = _src[j]
                sumX := sumX + x
                sumY := sumY + y
                sumXY := sumXY + x * y
                sumXX := sumXX + x * x
                sumXX
            float slope = -(i * sumXY - sumX * sumY) / (i * sumXX - sumX * sumX)
            if math.abs(slope) > math.abs(Slope_Absolute)
                Slope_Absolute := slope
                Length_Absolute := i
                Length_Absolute
        Length_Absolute

// Calculate R Length Zero Bias
// @function                Identifies the length with the lowest absolute R value.
// @param _src              (float) The source data.
// @param _len              (int) The maximum lookback length (minimum of 2).
// @param _minLen           (int) The minimum length to start from.
// @param _step             (int) The step for incrementing lengths.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast.
// @returns                 (int) The length with the lowest absolute R value.
export calcRLengthZero(float _src, int _len, int _minLen, int _step, bool _condition) =>
    if _condition and _len >= 2
        float lowAbsR = 1.0 //Highest possible R
        highLengthR = 0
        for i = _minLen > _len ? 2 : _minLen to _len by _step
            float avgSum = 0.0
            for int k = 1 to i by 1
                avgSum := avgSum + _src[k - 1]
                avgSum
            float average = avgSum / i
            float sumX = 0.0
            float sumY = 0.0
            float sumXY = 0.0
            float sumXX = 0.0
            for j = 0 to i - 1 by 1
                int x = j
                float y = _src[j]
                sumX := sumX + x
                sumY := sumY + y
                sumXY := sumXY + x * y
                sumXX := sumXX + x * x
                sumXX
            float slope = -(i * sumXY - sumX * sumY) / (i * sumXX - sumX * sumX)
            float y1 = average - slope * math.floor(i / 2) + (1 - i % 2) / 2 * slope
            float intercept = y1 + slope * (i - 1)
            float dsxx = 0.0
            float dsyy = 0.0
            float dsxy = 0.0
            int periods = i - 1
            float daY = intercept + slope * periods / 2
            float val = intercept
            for j = 0 to periods by 1
                float price = _src[j]
                float dxt = price - average
                float dyt = val - daY
                dsxx := dsxx + dxt * dxt
                dsyy := dsyy + dyt * dyt
                dsxy := dsxy + dxt * dyt
                val := val + slope
                val
            float R = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
            R := slope > 0 ? R * -1 : R
            if math.abs(R) <= math.abs(lowAbsR)
                lowAbsR := R
                highLengthR := i
                highLengthR
        highLengthR

// Calculate R Length Highest Value
// @function                Identifies the length with the highest R value.
// @param _src              (float) The source data.
// @param _len              (int) The maximum lookback length (minimum of 2).
// @param _minLen           (int) The minimum length to start from.
// @param _step             (int) The step for incrementing lengths.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast.
// @returns                 (int) The length with the highest R value.
export calcRLengthHighest(float _src, int _len, int _minLen, int _step, bool _condition) =>
    if _condition and _len >= 2
        float highR = -1.0 //Lowest possible R
        int highLengthR = 0
        for i = _minLen > _len ? 2 : _minLen to _len by _step
            float avgSum = 0.0
            for int k = 1 to i by 1
                avgSum := avgSum + _src[k - 1]
                avgSum
            float average = avgSum / i
            float sumX = 0.0
            float sumY = 0.0
            float sumXY = 0.0
            float sumXX = 0.0
            for j = 0 to i - 1 by 1
                int x = j
                float y = _src[j]
                sumX := sumX + x
                sumY := sumY + y
                sumXY := sumXY + x * y
                sumXX := sumXX + x * x
                sumXX
            float slope = -(i * sumXY - sumX * sumY) / (i * sumXX - sumX * sumX)
            float y1 = average - slope * math.floor(i / 2) + (1 - i % 2) / 2 * slope
            float intercept = y1 + slope * (i - 1)
            float dsxx = 0.0
            float dsyy = 0.0
            float dsxy = 0.0
            int periods = i - 1
            float daY = intercept + slope * periods / 2
            float val = intercept
            for j = 0 to periods by 1
                float price = _src[j]
                float dxt = price - average
                float dyt = val - daY
                dsxx := dsxx + dxt * dxt
                dsyy := dsyy + dyt * dyt
                dsxy := dsxy + dxt * dyt
                val := val + slope
                val
            float R = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
            R := slope > 0 ? R * -1 : R
            if R >= highR
                highR := R
                highLengthR := i
                highLengthR
        highLengthR

// Calculate R Length Lowest Value
// @function                Identifies the length with the lowest R value.
// @param _src              (float) The source data.
// @param _len              (int) The maximum lookback length (minimum of 2).
// @param _minLen           (int) The minimum length to start from.
// @param _step             (int) The step for incrementing lengths.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast.
// @returns                 (int) The length with the lowest R value.
export calcRLengthLowest(float _src, int _len, int _minLen, int _step, bool _condition) =>
    if _condition and _len >= 2
        float lowR = 1.0 //Highest possible R
        int lowLengthR = 0
        for i = _minLen > _len ? 2 : _minLen to _len by _step
            float avgSum = 0.0
            for int k = 1 to i by 1
                avgSum := avgSum + _src[k - 1]
                avgSum
            float average = avgSum / i
            float sumX = 0.0
            float sumY = 0.0
            float sumXY = 0.0
            float sumXX = 0.0
            for j = 0 to i - 1 by 1
                int x = j
                float y = _src[j]
                sumX := sumX + x
                sumY := sumY + y
                sumXY := sumXY + x * y
                sumXX := sumXX + x * x
                sumXX
            float slope = -(i * sumXY - sumX * sumY) / (i * sumXX - sumX * sumX)
            float y1 = average - slope * math.floor(i / 2) + (1 - i % 2) / 2 * slope
            float intercept = y1 + slope * (i - 1)
            float dsxx = 0.0
            float dsyy = 0.0
            float dsxy = 0.0
            int periods = i - 1
            float daY = intercept + slope * periods / 2
            float val = intercept
            for j = 0 to periods by 1
                float price = _src[j]
                float dxt = price - average
                float dyt = val - daY
                dsxx := dsxx + dxt * dxt
                dsyy := dsyy + dyt * dyt
                dsxy := dsxy + dxt * dyt
                val := val + slope
                val
            float R = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
            R := slope > 0 ? R * -1 : R
            if R <= lowR
                lowR := R
                lowLengthR := i
                lowLengthR
        lowLengthR

// Calculate R Length with Highest Absolute Value
// @function                Identifies the length with the highest absolute R value.
// @param _src              (float) The source data.
// @param _len              (int) The maximum lookback length (minimum of 2).
// @param _minLen           (int) The minimum length to start from.
// @param _step             (int) The step for incrementing lengths.
// @param _condition        (bool) Flag to enable calculation. Set to true to calculate on every bar; otherwise, set to barstate.islast.
// @returns                 (int) The length with the highest absolute R value.
export calcRLengthAbsolute(float _src, int _len, int _minLen, int _step, bool _condition) =>
    if _condition and _len >= 2
        float absoluteR = 0.0
        int absoluteLengthR = 0
        for i = _minLen > _len ? 2 : _minLen to _len by _step
            float avgSum = 0.0
            for int k = 1 to i by 1
                avgSum := avgSum + _src[k - 1]
                avgSum
            float average = avgSum / i
            float sumX = 0.0
            float sumY = 0.0
            float sumXY = 0.0
            float sumXX = 0.0
            for j = 0 to i - 1 by 1
                int x = j
                float y = _src[j]
                sumX := sumX + x
                sumY := sumY + y
                sumXY := sumXY + x * y
                sumXX := sumXX + x * x
                sumXX
            float slope = -(i * sumXY - sumX * sumY) / (i * sumXX - sumX * sumX)
            float y1 = average - slope * math.floor(i / 2) + (1 - i % 2) / 2 * slope
            float intercept = y1 + slope * (i - 1)
            float dsxx = 0.0
            float dsyy = 0.0
            float dsxy = 0.0
            int periods = i - 1
            float daY = intercept + slope * periods / 2
            float val = intercept
            for j = 0 to periods by 1
                float price = _src[j]
                float dxt = price - average
                float dyt = val - daY
                dsxx := dsxx + dxt * dxt
                dsyy := dsyy + dyt * dyt
                dsxy := dsxy + dxt * dyt
                val := val + slope
                val
            float R = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
            R := slope > 0 ? R * -1 : R
            if math.abs(R) >= math.abs(absoluteR)
                absoluteR := R
                absoluteLengthR := i
                absoluteLengthR
        absoluteLengthR

// Regressive Linear Deviation with Emphasis (Reverse)
// @function                Calculates the regressive linear deviation in reverse order, with optional emphasis on recent data.
// @param _src              (float) The source data.
// @param _len              (int) The length of the lookback period.
// @param _slope            (float) The slope of the linear regression.
// @param _y1               (float) The y-intercept (oldest bar) of the linear regression.
// @param _inputDev         (float) The input deviation multiplier.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 A 2-element tuple: [positive deviation, negative deviation].
export calcDevReverse(float _src, int _len, float _slope, float _y1, float _inputDev, float _emphasis = 0, bool _condition = true) =>
    if _condition and _len >= 2
        // Calculate EMA-style emphasis
        float emphasis = _emphasis-1
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasis)
        float sum_w = 0.0
        float sum_w_dev = 0.0
        float val = _y1 + _slope * (_len - 1)
        // Calculate Regressive
        for j = 0 to _len - 1 by 1
            float w = math.pow(1 - alpha, j)
            sum_w := sum_w + w
            sum_w_dev := sum_w_dev + w * math.pow(_src[j] - val, 2)
            val := val - _slope
        float dev = math.sqrt(sum_w_dev / sum_w)
        [dev * _inputDev, -dev * _inputDev]
    else
        [float(na), float(na)]

// Progressive Linear Deviation (Forward) with Emphasis
// @function                Calculates the progressive linear deviation in forward order (oldest to most recent bar), with optional emphasis.
// @param _src              (float) The source data array, where _src[0] is oldest and _src[_len - 1] is most recent.
// @param _len              (int) The length of the lookback period.
// @param _slope            (float) The slope of the linear regression.
// @param _y1               (float) The y-intercept of the linear regression (value at the most recent bar, adjusted by slope).
// @param _inputDev         (float) The input deviation multiplier.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 A 2-element tuple: [positive deviation, negative deviation].
export calcDevForward(float _src, int _len, float _slope, float _y1, float _inputDev, float _emphasis = 0, bool _condition = true) =>
    if _condition and _len >= 2
        float emphasis = _emphasis-1
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasis)
        float sum_w = 0.0
        float sum_w_dev = 0.0
        // Calculate Progressive
        for x = 0 to _len - 1 by 1
            float w = math.pow(1.0 - alpha, _len - 1 - x)
            sum_w := sum_w + w
            float line_val = _slope * (_len - x) + _y1
            sum_w_dev := sum_w_dev + w * math.pow(_src[x] - line_val, 2)
        float dev = math.sqrt(sum_w_dev / sum_w)
        [dev * _inputDev, -dev * _inputDev]
    else
        [float(na), float(na)]

// Balanced Linear Deviation with Emphasis
// @function                Calculates the balanced linear deviation with optional emphasis on recent or older data.
// @param _src              (float) Source data array, where _src[0] is the most recent and _src[_len - 1] is the oldest.
// @param _len              (int) The length of the lookback period.
// @param _slope            (float) The slope of the linear regression.
// @param _y1               (float) The y-intercept of the linear regression (value at the oldest bar).
// @param _inputDev         (float) The input deviation multiplier.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 A 2-element tuple: [positive deviation, negative deviation].
export calcDevBalanced(float _src, int _len, float _slope, float _y1, float _inputDev, float _emphasis = 0, bool _condition = true) =>
    if _condition and _len >= 2
        // Calculate EMA-style emphasis
        float emphasis = _emphasis-1
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasis)
        float sum_w = 0.0
        float sum_w_dev = 0.0
        // Calculate Balanced
        for i = 0 to _len - 1 by 1
            float w = math.pow(1.0 - alpha, _len - 1 - i)
            sum_w := sum_w + w
            float yValue = _y1 + _slope * i
            float dev = _src[_len - i - 1] - yValue
            sum_w_dev := sum_w_dev + w * dev * dev
        float dev = math.sqrt(sum_w_dev / sum_w)
        [dev * _inputDev, -dev * _inputDev]
    else
        [float(na), float(na)]

// Mean Absolute Deviation with Emphasis
// @function                Calculates the mean absolute deviation from a forward-applied linear trend (oldest to most recent), with optional emphasis.
// @param _src              (float) The source data array, where _src[0] is the most recent and _src[_len - 1] is the oldest.
// @param _len              (int) The length of the lookback period.
// @param _slope            (float) The slope of the linear regression.
// @param _y1               (float) The y-intercept (oldest bar) of the linear regression.
// @param _inputDev         (float) The input deviation multiplier.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 A 2-element tuple: [positive deviation, negative deviation].
export calcDevMean(float _src, int _len, float _slope, float _y1, float _inputDev, float _emphasis = 0, bool _condition = true) =>
    if _condition and _len >= 2
        // Calculate EMA-style emphasis
        float emphasis = _emphasis-1
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasis)
        float sum_w = 0.0
        float sum_w_dev = 0.0
        // Calculate Mean
        for i = 0 to _len - 1 by 1
            float w = math.pow(1.0 - alpha, i)
            sum_w := sum_w + w
            float line_value = _slope * (_len - i) + _y1
            float dev = math.abs(_src[i] - line_value)
            sum_w_dev := sum_w_dev + w * dev
        float dev = sum_w_dev / sum_w
        [dev * _inputDev, -dev * _inputDev]
    else
        [float(na), float(na)]

// Median Absolute Deviation with Emphasis
// @function                Calculates the median absolute deviation with optional emphasis on recent data.
// @param _src              (float) The source data array (index 0 = oldest, index _len - 1 = most recent).
// @param _len              (int) The length of the lookback period.
// @param _slope            (float) The slope of the linear regression.
// @param _y1               (float) The y-intercept (oldest bar) of the linear regression.
// @param _inputDev         (float) The deviation multiplier.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 [positive deviation, negative deviation]
export calcDevMedian(float _src, int _len, float _slope, float _y1, float _inputDev, float _emphasis = 0, bool _condition = true) =>
    if _condition and _len >= 2
        // Calculate EMA-style emphasis
        float emphasis = _emphasis-1
        float alpha = emphasis > 0 ? 2.0 / (_len + 1) * emphasis : 0.0
        // Arrays for deviations and weights
        devs_arr = array.new_float(_len)
        weights = array.new_float(_len)
        for i = 0 to _len - 1
            float absDev = math.abs(_src[i] - (_slope * (_len - i) + _y1))
            devs_arr.set(i, absDev)
            // Weights: higher for recent data (i closer to _len-1)
            float w = math.pow(1.0 - alpha, _len - 1 - i)
            weights.set(i, w)
        // Get sorted indices of deviations
        sorted_indices = array.sort_indices(devs_arr, order.ascending)
        // Calculate weighted median
        float total_weight = array.sum(weights)
        float cumulative_weight = 0.0
        float dev = 0.0
        for i = 0 to _len - 1
            int idx = sorted_indices.get(i)
            cumulative_weight := cumulative_weight + weights.get(idx)
            if cumulative_weight >= total_weight / 2
                dev := devs_arr.get(idx)
                break
        // Return positive and negative deviations
        [dev * _inputDev, -dev * _inputDev]
    else
        [float(na), float(na)]

// Percent Deviation
// @function                Calculates the percent deviation from a given value and a specified percentage.
// @param _y1               (float) The base value from which to calculate deviation.
// @param _inputDev         (float) The deviation percentage.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 A 2-element tuple: [positive deviation, negative deviation].
export calcDevPercent(float _y1, float _inputDev, bool _condition = true) =>
    if _condition
        float dev = _y1 * (_inputDev / 100)
        [dev, -dev]

// Fitted Deviation with EMA Weighting and Emphasis
// @function                Calculates the weighted fitted deviation based on high and low series data, showing max deviation, with optional emphasis.
// @param _len              (int) The length of the lookback period.
// @param _slope            (float) The slope of the linear regression.
// @param _y1               (float) The Y-intercept (oldest bar) of the linear regression.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 A 2-element tuple: [weighted highest deviation, weighted lowest deviation].
export calcDevFitted(int _len, float _slope, float _y1, float _emphasis = 0, bool _condition = true) =>
    if _condition and _len >= 2
        // Calculate EMA-style emphasis
        float emphasis = _emphasis-1
        float alpha = 2.0 / (_len + 1) * (1.0 + emphasis)
        // Calculate lambda as the decay factor
        float _lambda = 1.0 - alpha
        // Initialize deviation trackers
        float topDev = 0.0
        float botDev = 0.0
        for j = 0 to _len - 1 by 1
            float w = math.pow(_lambda, j)
            float val = _y1 + _slope * (_len - 1 - j)
            float weightedTop = w * (high[j] - val)
            float weightedBot = w * (val - low[j])
            topDev := math.max(topDev, weightedTop)
            botDev := math.max(botDev, weightedBot)
        [topDev, -botDev]
    else
        [float(na), float(na)]

// Average True Range Deviation with Emphasis
// @function                Calculates an ATR-style deviation with optional emphasis on recent data.
// @param _src              (float) The source data (typically close).
// @param _len              (int) The length of the lookback period.
// @param _slope            (float) The slope of the linear regression.
// @param _y1               (float) The Y-intercept (oldest bar) of the linear regression.
// @param _inputDev         (float) The input deviation multiplier.
// @param _emphasis         (float) Emphasis factor: 0 for equal weight; >0 emphasizes recent bars; <0 emphasizes older bars.
// @param _condition        (bool) Flag to enable calculation (true = calculate).
// @returns                 A 2-element tuple: [positive deviation, negative deviation].
export calcDevATR(float _src, int _len, float _slope, float _y1, float _inputDev, float _emphasis = 0, bool _condition = true) =>
    if _condition and _len >= 2
        float initialLineVal = _y1 + _slope * (_len - 1)
        float devATR = math.abs(_src[0] - initialLineVal)
        for i = 1 to _len - 1 by 1
            float weight = 1.0 + _emphasis * (i / float(_len - 1))
            float line_val = _y1 + _slope * (_len - 1 - i)
            float currentDev = math.abs(_src[i] - line_val)
            devATR := ((devATR * (_len - 1)) + (currentDev * weight)) / _len
        [devATR * _inputDev, -devATR * _inputDev]
    else
        [float(na), float(na)]

// Percent Position
// @function                Calculates the percent position of a price within a linear regression channel. Top=100%, Bottom=0%.
// @param _src              (float) The source price.
// @param _top              (float) The top (positive) deviation, corresponding to 100%.
// @param _bot              (float) The bottom (negative) deviation, corresponding to 0%.
// @returns                 (float) The percent position within the channel.
export calcPricePositionPercent(float _top, float _bot, float _src) =>
    (_src - _bot) / (_top - _bot) * 100

// Plot Linear Regression and Deviations (Channel)
// @function                Plots the linear regression line and its deviations, with configurable styles and fill.
// @param _len              (int) The lookback period for the linear regression.
// @param _y1               (float) The starting y-value of the regression line.
// @param _y2               (float) The ending y-value of the regression line.
// @param _slope            (float) The slope of the regression line (used to determine line color).
// @param _devTop           (float) The top deviation to add to the line.
// @param _devBot           (float) The bottom deviation to subtract from the line.
// @param _scaleTypeLog     (bool) Use a log scale if true; otherwise, linear scale.
// @param _lineWidth        (int) The width of the plotted lines.
// @param _extendLines      (string) How lines should extend (none, left, right, both).
// @param _channelStyle     (string) The style of the channel lines (solid, dashed, dotted).
// @param _colorFill        (bool) Whether to fill the space between the top and bottom deviation lines.
// @param _colUpLine        (color) Line color when slope is positive.
// @param _colDnLine        (color) Line color when slope is negative.
// @param _colUpFill        (color) Fill color when slope is positive.
// @param _colDnFill        (color) Fill color when slope is negative.
export plotLinReg(int _len, float _y1, float _y2, float _slope, float _devTop, float _devBot, bool _scaleTypeLog = false, int _lineWidth = 1, string _extendLines = extend.none, string _channelStyle = line.style_dashed, bool _colorFill = true, color _colUpLine = #78ff7a, color _colDnLine = #ff7878, color _colUpFill = na, color _colDnFill = na) =>
    var line midline = na
    var line topLine = na
    var line botLine = na
    int x = bar_index - (math.max(_len, 1) - 1)
    color colLine = _slope >= 0 ? _colUpLine : _colDnLine
    float y1_upper = _scaleTypeLog ? _y1 * math.pow(10, _devTop) : _y1 + _devTop
    float y2_upper = _scaleTypeLog ? _y2 * math.pow(10, _devTop) : _y2 + _devTop
    float y1_lower = _scaleTypeLog ? _y1 * math.pow(10, _devBot) : _y1 + _devBot
    float y2_lower = _scaleTypeLog ? _y2 * math.pow(10, _devBot) : _y2 + _devBot
    if not na(midline)
        line.delete(midline)
    if not na(topLine)
        line.delete(topLine)
    if not na(botLine)
        line.delete(botLine)
    midline := line.new(x1 = x, y1 = _y1, x2 = bar_index, y2 = _y2, color = colLine, style = line.style_solid, width = _lineWidth, extend = _extendLines)
    topLine := line.new(x1 = x, y1 = y1_upper, x2 = bar_index, y2 = y2_upper, color = colLine, style = _channelStyle, width = _lineWidth, extend = _extendLines)
    botLine := line.new(x1 = x, y1 = y1_lower, x2 = bar_index, y2 = y2_lower, color = colLine, style = _channelStyle, width = _lineWidth, extend = _extendLines)
    if _colorFill
        linefill.new(botLine, topLine, _slope >= 0 ? _colUpFill : _colDnFill)
