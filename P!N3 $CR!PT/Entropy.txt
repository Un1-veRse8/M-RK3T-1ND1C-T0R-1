// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ScorsoneEnterprises

//@version=6
indicator('Entropy [ScorsoneEnterprises]', 'SCE En')

// Settings
N = input.int(50, 'Lookback Period', minval = 10, group = 'Entropy Parameters')
SMA_N = input.int(100, 'Reference SMA Lookback Period', minval = 10, group = 'Entropy Parameters')
bins = input.int(20, 'Number of Bins', minval = 2, group = 'Entropy Parameters')

// Function to compute entropy with binning
compute_entropy(values) =>
    n = array.size(values)
    if n == 0
        0.0
    else // Find min and max for binning
        min_val = array.min(values)
        max_val = array.max(values)
        if min_val == max_val
            0.0
        else
            bin_width = (max_val - min_val) / bins
            freq_array = array.new_float(bins, 0)
            total_count = 0
            // Assign values to bins
            for i = 0 to n - 1 by 1
                val = array.get(values, i)
                if not na(val)
                    bin_idx = math.min(bins - 1, math.max(0, math.floor((val - min_val) / bin_width)))
                    array.set(freq_array, bin_idx, array.get(freq_array, bin_idx) + 1)
                    total_count := total_count + 1
                    total_count
            // Compute entropy
            entropy = 0.0
            for i = 0 to bins - 1 by 1
                count = array.get(freq_array, i)
                if count > 0
                    p = count / total_count
                    entropy := entropy - p * math.log(p)
                    entropy
            entropy

// Calculations
var float en = na
var lgr = array.new_float(N, na)

// Update log returns array
if bar_index >= N
    for i = N - 1 to 1 by 1
        array.set(lgr, i, array.get(lgr, i - 1))
    new_log_ret = not na(close) and not na(close[1]) ? math.log(close / close[1]) : na
    array.set(lgr, 0, new_log_ret)

// Compute entropy only if enough valid data
if array.size(lgr) == N
    en := compute_entropy(lgr)

ref_ma = ta.sma(en, SMA_N)

// Plots
plot(en, 'Entropy', color = color.from_gradient(en, ta.lowest(en, N), ta.highest(en, N), color.red, color.teal), linewidth = 2)
plot(ref_ma, 'Reference Entropy SMA', color = en > ref_ma ? color.teal : color.red, linewidth = 2)