// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © AlgoAlpha

//@version=6
indicator(title="Liquidity Depth [AlgoAlpha]", shorttitle="AlgoAlpha - Liquidity Depth", overlay = true, max_lines_count = 500, max_boxes_count = 500)
import TradingView/ta/9

plook = input.int(500, "Liquidity Lookback", tooltip = "Number of bars to look back for calculating liquidity levels. Higher values provide more historical context but may slow down calculations.", group = "Liquidity Settings")
useseconds = input.bool(false, "Use Seconds", tooltip = "When enabled, the indicator will use volume data on the seconds resolution for its calculations", group = "Liquidity Settings")

interpol = input.bool(true, "Interpolation", tooltip = "When enabled, lines will be drawn to visualise the comparison between the upper and lower liquidity.", group = "Visualization")
scale = input.int(70, "Scale Factor", tooltip = "Adjusts the visual scaling of the liquidity display. Higher values make the profile wider.", group = "Visualization")
focus_range = input.float(0.5, "Focus Range %", tooltip = "Defines the range of price levels to emphasize in the visualization. Higher values widen the focus area around current price.", group = "Visualization")
res = input.int(120, "Profile Resolution", tooltip = "Controls the granularity of the liquidity visualization. Higher values create more detailed liquidity profiles but may impact performance.", group = "Visualization", maxval = 250, minval = 1)

green = input.color(#00ffbb, "Up Color", group = "Appearance")
red = input.color(#ff1100, "Down Color", group = "Appearance")

if na(volume)
    runtime.error("No volume data, please try another ticker")

// Calculating
candledir = close > open ? 1 : -1
candlelen = math.abs(close-open)

dynamic_ltf = ""

if timeframe.ismonthly
    dynamic_ltf := "W"
if timeframe.isweekly
    dynamic_ltf := "D"
if timeframe.isdaily
    dynamic_ltf := "60"
if timeframe.isminutes and timeframe.multiplier > 120
    dynamic_ltf := "15"
else if timeframe.isminutes and timeframe.multiplier > 60
    dynamic_ltf := "10"
else if timeframe.isminutes and timeframe.multiplier > 30
    dynamic_ltf := "5"
else
    dynamic_ltf := useseconds ? "15S" : "1"

// Get up and down volume
[upvolume, downvolume, volumedelta] = ta.requestUpAndDownVolume(dynamic_ltf)

// Normalize volumes using min-max normalization
// norm_upvolume = (upvolume - ta.lowest(upvolume, 100)) / (ta.highest(upvolume, 100) - ta.lowest(upvolume, 100))
// norm_downvolume = (downvolume - ta.lowest(downvolume, 100)) / (ta.highest(downvolume, 100) - ta.lowest(downvolume, 100))

norm_downvolume = (upvolume - ta.lowest(upvolume, int(plook/2))) / (ta.highest(upvolume, int(plook/2)) - ta.lowest(upvolume, int(plook/2)))
norm_upvolume = (math.abs(downvolume) - ta.lowest(math.abs(downvolume), int(plook/2))) / (ta.highest(math.abs(downvolume), int(plook/2)) - ta.lowest(math.abs(downvolume), int(plook/2)))


type bar
    float h = high
    float l = low
    float v = volume
    int   i = bar_index

//-----------------------------------------------------------------------------}
// Variables
//-----------------------------------------------------------------------------{

bar b = bar.new()
x = 0.0
var xx = 0.0
var hh = 0.0
var ll = 0.0
var aR = array.new_line()
var aS = array.new_line()
var aRv = array.new_float(1)
var aSv = array.new_float(1)

var lowervolumes = array.new_float()
var lowervolumes_levels = array.new_float()
var highervolumes = array.new_float()
var highervolumes_levels = array.new_float()

// Calculate transparency based on normalized volume (0-100 range)
high_transparency = math.min(math.round(100 - norm_downvolume * 100), 80) //norm_downvolume
low_transparency = math.min(math.round(100 - norm_upvolume * 100), 80) //norm_upvolume

// Draw at every high and low with volume-based transparency
aR.push(line.new(bar_index, high, bar_index+1, high, color = color.new(red, high_transparency), width = 3))
array.push(highervolumes, 100 - high_transparency)
array.push(highervolumes_levels, high)

aS.push(line.new(bar_index, low, bar_index+1, low, color = color.new(green, low_transparency), width = 3))
array.push(lowervolumes, 100 - low_transparency)  // Store inverse transparency for the low line
array.push(lowervolumes_levels, low)

if aR.size() > 0
    qt = aR.size()
    for ln = qt - 1 to 0
        if ln < aR.size()
            cL = aR.get(ln)
            yL = cL.get_y1()
            start_x = cL.get_x1()  // Get the starting bar index of the line
            // Delete the line if the current high breaks above its level
            // OR if the line falls outside the liquidity lookback period
            if high > yL or (b.i - start_x > plook)
                cL.delete()  // Delete the line from chart
                aR.remove(ln)
                array.remove(highervolumes, ln)  // Remove corresponding volume
                array.remove(highervolumes_levels, ln)  // Remove corresponding price level
                x := close < yL and open > close ? 1 : 0
            else
                cL.set_x2(b.i + 1)
    if aR.size() > 500
        aR.shift().delete()
        array.shift(highervolumes)
        array.shift(highervolumes_levels)


if aS.size() > 0
    qt = aS.size()
    for ln = qt - 1 to 0
        if ln < aS.size()
            cL = aS.get(ln)
            yL = cL.get_y1()
            start_x = cL.get_x1()  // Get the starting bar index of the line
            // Delete the line if the current low falls below its level
            // OR if the line falls outside the liquidity lookback period
            if low < yL or (b.i - start_x > plook)
                cL.delete()  // Delete the line from chart
                aS.remove(ln)
                array.remove(lowervolumes, ln)  // Remove corresponding inverse transparency
                array.remove(lowervolumes_levels, ln)  // Remove corresponding price level
            else
                cL.set_x2(b.i + 1)

    if aS.size() > 500
        aS.shift().delete()
        array.shift(lowervolumes)
        array.shift(lowervolumes_levels)

var poc = 0.0
var left = 0
var boxes = array.new_box()
var lines = array.new_line()
var binlen = array.new_float()  // Array to store bin sizes
top_boundaries = array.new_float(res)
bottom_boundaries = array.new_float(res)

// Use current price as the upper boundary
maxx = close
// Use the minimum of lower volume levels as the lower boundary
minn = array.size(lowervolumes_levels) > 0 ? array.min(lowervolumes_levels) : low
size = array.size(lowervolumes)

while boxes.size() > 0
    boxes.shift().delete()
while lines.size() > 0
    lines.shift().delete()

// Define variables for the upper volume profile
size_above = array.size(highervolumes)
var binlenAbove = array.new_float()
high_bottom_boundaries = array.new_float(res)
high_top_boundaries = array.new_float(res)
var boxesAbove = array.new_box()

// Use the maximum of higher volume levels as the upper boundary
max_above = array.size(highervolumes_levels) > 0 ? array.max(highervolumes_levels) : high
// Use current price as the lower boundary
min_above = close

focus_range_ = focus_range/100

// Clear existing boxes for upper profile
while boxesAbove.size() > 0
    boxesAbove.shift().delete()

// Process both profiles to calculate bin sizes
if size > 0 and barstate.islast
    // Clear the binlen array before reusing
    while array.size(binlen) > 0
        array.pop(binlen)
        
    step = (maxx - minn) / res
    granularity = res
    for i = 0 to granularity - 1
        bin_size = 0.0
        bottom = minn + (i*step)
        top = minn + ((i+1)*step)
        bottom_boundaries.insert(i, bottom)
        top_boundaries.insert(i, top)   
        
        // Only process levels below the current price
        if top <= close
            for j = 0 to array.size(lowervolumes_levels) - 1
                level = lowervolumes_levels.get(j)
                // Check if the level is within this bin
                if level >= bottom
                    // Use the corresponding volume weight from lowervolumes
                    bin_size += lowervolumes.get(j)
        
        array.push(binlen, bin_size)

if size_above > 0 and barstate.islast
    // Clear the binlenAbove array before reusing
    while array.size(binlenAbove) > 0
        array.pop(binlenAbove)
        
    step_above = (max_above - min_above) / res
    granularity = res
    for i = 0 to granularity - 1
        bin_size_above = 0.0
        bottom_above = min_above + (i * step_above)
        top_above = min_above + ((i + 1) * step_above)
        high_bottom_boundaries.set(i, bottom_above)
        high_top_boundaries.set(i, top_above)
        
        // Only process levels above the current price
        if bottom_above >= close
            for j = 0 to array.size(highervolumes_levels) - 1
                level = highervolumes_levels.get(j)
                // Check if the level is within this bin
                if level <= top_above
                    bin_size_above += highervolumes.get(j)
        
        array.push(binlenAbove, bin_size_above)

// Find the maximum bin size across both profiles for unified scaling
max_bin_size = 0.0
if array.size(binlen) > 0
    max_bin_size := array.max(binlen)
if array.size(binlenAbove) > 0
    max_bin_size := math.max(max_bin_size, array.max(binlenAbove))

global_boxleft_up = 0
global_boxleft_down = 0
var scan_level_lower = 0.0
var scan_level_upper = 0.0

// Only draw if we have valid data
if max_bin_size > 0
    scan_level_lower := close - close * focus_range_
    scan_level_upper := close + close * focus_range_
    
    // Plot the lower profile
    if array.size(binlen) > 0 and barstate.islast
        for i = 0 to res - 1
            if i < array.size(binlen)
                box_right = bar_index + 7 + scale
                box_left = box_right - math.round(binlen.get(i))/math.round(max_bin_size) * scale
                box_top = array.get(top_boundaries, i)
                box_bottom = array.get(bottom_boundaries, i)
                left := box_left
                
                // Check if the bin is above the lower scan line (for green/lower bins)
                is_in_scan_range = box_top >= scan_level_lower
                
                // Use 90 transparency for bins outside the scan range, normal transparency for bins inside
                transparency = is_in_scan_range ? 50 : 90
                border_transparency = is_in_scan_range ? 40 : 90
                
                boxes.push(box.new(box_left, box_top, box_right, box_bottom, 
                                  border_style = line.style_solid, 
                                  border_color = color.new(green, border_transparency), 
                                  border_width = 1, 
                                  bgcolor = color.new(green, transparency)))
                if math.min(box_bottom, box_top) <= scan_level_lower and math.max(box_bottom, box_top) >= scan_level_lower
                    global_boxleft_up := box_left
                    lines.push(line.new(bar_index, scan_level_lower, box_left, scan_level_lower,
                                      color=color.new(color.gray, 0), width=1))
    
    // Plot the upper profile
    if array.size(binlenAbove) > 0 and barstate.islast
        for i = 0 to res - 1
            if i < array.size(binlenAbove)
                box_right = bar_index + 7 + scale
                box_left = box_right - math.round(binlenAbove.get(i)) / math.round(max_bin_size) * scale
                box_top = high_top_boundaries.get(i)
                box_bottom = high_bottom_boundaries.get(i)
                
                // Check if the bin is below the upper scan line (for red/upper bins)
                is_in_scan_range = box_bottom <= scan_level_upper
                
                // Use 90 transparency for bins outside the scan range, normal transparency for bins inside
                transparency = is_in_scan_range ? 50 : 90
                border_transparency = is_in_scan_range ? 40 : 90
                
                boxesAbove.push(box.new(box_left, box_top, box_right, box_bottom,
                                  border_style = line.style_solid,
                                  border_color = color.new(red, border_transparency),
                                  border_width = 1,
                                  bgcolor = color.new(red, transparency)))
                if math.min(box_bottom, box_top) <= scan_level_upper and math.max(box_bottom, box_top) >= scan_level_upper
                    global_boxleft_down := box_left
                    lines.push(line.new(bar_index, scan_level_upper, box_left, scan_level_upper,
                                      color=color.new(color.gray, 0), width=1))

if lines.size() > 1
    lines.push(line.new(bar_index, close, bar_index + 7 + scale, close, style=line.style_dashed, color = lines.first().get_x2() > lines.get(1).get_x2() ? red : green, width=1))

var interpolation_lines = array.new_line()

while interpolation_lines.size() > 0
    interpolation_lines.shift().delete()

if lines.size() > 1
    if interpol
        interpolation_lines.push(line.new(lines.get(0).get_x2(), close-close*focus_range_, lines.get(0).get_x2(), close, style=line.style_solid, color = green, width=1))
        interpolation_lines.push(line.new(lines.get(1).get_x2(), close+close*focus_range_, lines.get(1).get_x2(), close, style=line.style_solid, color = red, width=1))
