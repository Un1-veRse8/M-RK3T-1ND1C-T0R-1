// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=6
indicator('Bitcoin Power Law Clock [LuxAlgo]', 'LuxAlgo - Bitcoin Power Law Clock', max_labels_count = 500, max_polylines_count = 100, max_bars_back = 5000)
//---------------------------------------------------------------------------------------------------------------------}
//EXECUTION CHECKS
//---------------------------------------------------------------------------------------------------------------------{
// we execute only in BTCUSD tickers
if ticker.standard()    != 'INDEX:BTCUSD'
    runtime.error('This indicator is only available for INDEX:BTCUSD (Bitcoin all time history index), change your chart ticker')

// we execute only in Daily timeframe
if timeframe.period     != '1D'
    runtime.error('This indicator is only available for the daily timeframe')

//---------------------------------------------------------------------------------------------------------------------}
//CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
EN_SPACE                = ' '
EM_SPACE                = ' '
FOUR_PER_EM_SPACE       = ' '
SIX_PER_EM_SPACE        = ' '
HAIR_SPACE              = ' '

showPriceSpacing        = EN_SPACE+EM_SPACE+SIX_PER_EM_SPACE
showAverageSpacing      = FOUR_PER_EM_SPACE
autoScaleSpacing        = HAIR_SPACE
textSizeSpacing         = EM_SPACE+EM_SPACE+FOUR_PER_EM_SPACE
priceScaleSpacing       = EM_SPACE+EM_SPACE+SIX_PER_EM_SPACE
clockHandleSpacing      = EM_SPACE+EN_SPACE+SIX_PER_EM_SPACE+HAIR_SPACE
halvingsSpacing         = EM_SPACE+HAIR_SPACE+HAIR_SPACE

PRICE_GROUP             = 'PRICE'
STYLE_GROUP             = 'STYLE'
DASHBOARD_GROUP         = 'Time & Price Dashboard'

showPriceTooltip        = 'Enable/disable price spiral, select colour and enable/disable curved mode'
showAverageTooltip      = 'Enable/disable average spiral, select colour and enable/disable curved mode'
showForecastTooltip     = 'Enable/disable forecast spiral, select colour and enable/disable curved mode'
autoScaleTooltip        = 'Enable/disable automatic scaling or set manual fixed scaling for the spirals'
linesWidthTooltip       = 'Width of each spiral line'
textSizeTooltip         = 'Select text size for date tags and price scales'
showTagsTooltip         = 'Enable/disable date tags'
showPriceScaleTooltip   = 'Enable/disable price scales on the x-axis'
showClockHandleTooltip  = 'Enable/disable clock handle'
showHoursTooltip        = 'Enable/disable hours and key cycle points'
showHalvingsTooltip     = 'Enable/disable Halvings'

showPriceInput          = input.bool(   true,       'Price'+showPriceSpacing,       group = PRICE_GROUP,    tooltip='',                     inline = 'price')
priceColorInput         = input.color(#9598A1,    '',                             group = PRICE_GROUP,    tooltip='',                     inline = 'price')
priceCurvedInput        = input.bool(   true,       'Curved',                       group = PRICE_GROUP,    tooltip = showPriceTooltip,     inline = 'price')

showAverageInput        = input.bool(   true,       'Average'+showAverageSpacing,   group=PRICE_GROUP,      tooltip='',                     inline='average')
averageColorInput       = input.color(color.yellow,'',                            group=PRICE_GROUP,      tooltip='',                     inline='average')
averageCurvedInput      = input.bool(   true,       'Curved',                       group=PRICE_GROUP,      tooltip=showAverageTooltip,     inline='average')

autoScaleInput          = input.bool(   true,       'Auto scale'+autoScaleSpacing,  group=STYLE_GROUP,      tooltip='',                     inline='scale')
scaleMultiplierInput    = input.int(    100,        '',                             group=STYLE_GROUP,      tooltip=autoScaleTooltip,       inline='scale', minval=10,  step=10)

linesWidthInput         = input.int(    1,          'Lines width',                  group=STYLE_GROUP,      tooltip=linesWidthTooltip)
textSizeInput           = input.string( size.small, 'Text Size'+textSizeSpacing,    group=STYLE_GROUP,      tooltip=textSizeTooltip,        options=[size.tiny,size.small,size.normal,size.large,size.huge])

showPriceScaleInput     = input.bool(   true,       'Prices',                       group=STYLE_GROUP,      tooltip=showPriceScaleTooltip,  inline = 'priceScale')
priceScaleColorInput    = input.color(color.new(color.yellow,25), priceScaleSpacing,group=STYLE_GROUP,    tooltip=showPriceScaleTooltip,  inline = 'priceScale')

showClockHandleInput    = input.bool(   true,       'Handle',                       group=STYLE_GROUP,      tooltip=showClockHandleTooltip, inline = 'handle')
clockHandleColorInput   = input.color(color.red,  clockHandleSpacing   ,          group=STYLE_GROUP,      tooltip=showClockHandleTooltip, inline = 'handle')

showHalvingsInput       = input.bool(   true,       'Halvings',                     group=STYLE_GROUP,      tooltip='',                     inline = 'halvings')
halvingsColorInput      = input.color(color.new(color.silver,50), halvingsSpacing,group=STYLE_GROUP,      tooltip=showHalvingsTooltip,    inline = 'halvings')

showHoursInput          = input.bool(   true,       'Hours',                        group=STYLE_GROUP,      tooltip=showHoursTooltip)

showDashboardInput      = input.bool     ( true,       'Show Time & Price',    group = DASHBOARD_GROUP)
dashboardLocationInput  = input.string   ( 'Top Right','Location',             group = DASHBOARD_GROUP, options = ['Top Right', 'Bottom Right', 'Bottom Left'])
dashboardSizeInput      = input.string   ( 'Small',    'Size',                 group = DASHBOARD_GROUP, options = ['Tiny', 'Small', 'Normal'])

var table_position = dashboardLocationInput == 'Bottom Left' ? position.bottom_left 
  : dashboardLocationInput == 'Top Right' ? position.top_right 
  : position.bottom_right

var table_size = dashboardSizeInput == 'Tiny' ? size.tiny 
  : dashboardSizeInput == 'Small' ? size.small 
  : size.normal

var tb = table.new(table_position, 1, 2
  , bgcolor      = #1e222d
  , border_color = #373a46
  , border_width = 1
  , frame_color  = #373a46
  , frame_width  = 1)

//---------------------------------------------------------------------------------------------------------------------}
//DATA STRUCTURES & VARIABLES
//---------------------------------------------------------------------------------------------------------------------{
type s_tring
    string tag
var s_tring clockTime = s_tring.new()

// @type                Store close & time for each bar
// @field price         store close value for each candle
// @field milliseconds  store time values for each candle
type bar
    float price
    int milliseconds

// @variable            storage for bar UDTs
var array<bar> bars             = array.new<bar>()
// @variable            storage for time halvings
var halvings                    = array.from(timestamp(2012, 11, 28), timestamp(2016, 07, 09), timestamp(2020, 05, 11), timestamp(2024, 04, 20))
// @variable            4 years per BTC cycle 365*4
var barsPerCyleInput            = 1460
// @variable            how many date tags we will be showing
var tagsPerCycleInput           = 8
// @variable            left bound for anchoring the spirals
var int left_visible_bar_index  = 0
// @variable            right bound for anchoring the spirals
var int right_visible_bar_index = last_bar_index
// @variable            storage for close prices
var array<float> dataPoints     = array.new<float>()
// @variable            storage for double ema filter
var array<float> secondPass     = array.new<float>()

//---------------------------------------------------------------------------------------------------------------------}
//USER-DEFINED FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
// @function            transforms polar coordinates to cartesian ones for a clock wise spiral
// @param rho           rho as price
// @param theta         theta as angle, one cycle is 2*math.pi
// @param rotate        if true rotates spiral 90 degrees counter clock wise
// @returns             float tuple
polar2Cartesian(rho, theta, bool rotate = true) =>
    parsedTheta = rotate ? theta - 0.5 * math.pi : theta
    x           = rho * math.cos(-parsedTheta)
    y           = rho * math.sin(-parsedTheta)
    [x, y]

// @function            get a chart.point from polar coordinates rho and theta
// @param rho           rho as price
// @param theta         theta as angle, one cycle is 2*math.pi
// @param scale         scale to use for the spiral width
// @param anchor        anchor point for the spiral center
// @param rotate        if true rotates spiral 90 degrees counter clock wise
// @returns             chart.point
spiralPoint(rho, theta, anchor, scale, bool rotate = true) => 
    [x, y]      = polar2Cartesian(rho, theta,rotate) 
    parsedScale = autoScaleInput ? scale : scaleMultiplierInput
    index       = math.min(anchor + math.round( parsedScale * x ),last_bar_index + 500)     
    price       = parsedScale * y + hl2 

    chart.point.new(na, index, price)

// @function            double ema forward/backward filter
// @param               source like close prices
// @param               length for the ema
// @returns             array<float>
filtfilt(source, smoothing)=>
    var alpha       = 2/(smoothing+1)
    var ema1        = source
    var first_pass  = array.new<float>(0)

    //Compute first pass smoothing using EMA
    ema1            += alpha * (source - ema1)

    //Unshift to array
    first_pass.unshift(ema1)
    second_pass     = array.new<float>(0)

    if barstate.islastconfirmedhistory
        ema2 = ema1
        for [index, element] in first_pass
            ema2 += alpha * (element - ema2)
            second_pass.unshift(ema2)

    second_pass

// @function            plot tables for 3, 6, 9 & 12 clock hours
// @param position      where it will be plotted
// @param cellText      text to display
// @param textColor     colour of displayed text
// @returns             void
plotTable(string position,string cellText,color textColor) =>
    var table t_able = table.new(position,1,1,color(na),color(na))
    table.cell(t_able,0,0,cellText,text_color=textColor,text_size=size.large)

// @function            plot all spirals, labels and tables
// @returns             label ID
plotSpiral() =>    
    var step                                = (2 * math.pi) / barsPerCyleInput
    var array<chart.point> chartPoints      = array.new<chart.point>()
    var array<chart.point> forecastPoints   = array.new<chart.point>()
    var array<chart.point> averagePoints    = array.new<chart.point>()
    var array<int> spiralDates              = array.new<int>()
    var array<float> forecastRhos           = array.new<float>()

    // we get scale & anchor for drawing the spirals   
    maxTheta                = (array.size(dataPoints) - 1) * step
    maxThetaByPi            = maxTheta / math.pi
    
    secondsByLap            = 12 * 60 * 60
    locationOnLap           = maxTheta / (2 * math.pi) - int(maxTheta / (2 * math.pi))
    locationSeconds         = int(locationOnLap * secondsByLap) + 60
    locationMinutes         = int(locationSeconds / 60)
    locationHours           = int(locationMinutes / 60) 
    parsedLocationMinutes   = int((locationMinutes / 60 - locationHours) * 60)
    
    clockTime.tag           := str.format('{0}:{1,number,00}',locationHours,parsedLocationMinutes)       

    leftmostTheta           = .0
    rightmostTheta          = .0

    if int(maxThetaByPi) % 2 == 0
        if (maxThetaByPi - int(maxThetaByPi)) > 0.5
            leftmostTheta   := int(maxThetaByPi) + 1
            rightmostTheta  := int(maxThetaByPi)
        else
            leftmostTheta   := int(maxThetaByPi) - 1
            rightmostTheta  := int(maxThetaByPi)
    else
        if (maxThetaByPi - int(maxThetaByPi)) > 0.5
            leftmostTheta   := int(maxThetaByPi)
            rightmostTheta  := int(maxThetaByPi) + 1
        else
            leftmostTheta   := int(maxThetaByPi)
            rightmostTheta  := int(maxThetaByPi) - 1

    leftmostTheta       *= math.pi    
    rightmostTheta      *= math.pi  

    lastDataPoint       = array.get(dataPoints, array.size(dataPoints) - 1)
    leftmostBarIndex    = math.round(lastDataPoint * math.cos(leftmostTheta))
    rightmostBarIndex   = math.round(lastDataPoint * math.cos(rightmostTheta))    
    spiralWidthInBars   = math.abs(leftmostBarIndex) + rightmostBarIndex
    visibleWidthInBars  = right_visible_bar_index - left_visible_bar_index
    spiralSize          = 2 * math.max(math.abs(leftmostBarIndex), rightmostBarIndex)
    spiralScale         = math.round(0.5 * visibleWidthInBars) / spiralSize    
    spiralAnchor        = right_visible_bar_index - math.round(0.5 * visibleWidthInBars)    
    maxDataIndex        = dataPoints.size() - 1    
       
    // we gather chart.point array for plotting price spiral starting at 700 (hardcoded data fix)
    if showPriceInput
        dataMin = dataPoints.min()
        for [index,eachDataPoint] in dataPoints
            if index >= 700
                theta = (index) * step
                array.push(chartPoints,spiralPoint(eachDataPoint,theta,spiralAnchor,spiralScale))
                spiralDates.push(bars.get(index).milliseconds)            
       
    // we gather chart.point array for plotting average (double ema filter) spiral starting at 700 (hardcoded data fix)
    if showAverageInput
        secondPassMin = secondPass.min()
        for [index,element] in secondPass
            if index >= 700
                theta = index * step        
                averagePoints.push(spiralPoint(element,theta,spiralAnchor,spiralScale))            
   
    // we plot all three spirals as per the active settings, we do it this way to use chained polylines to draw spirals with more than 10000 chart.points
    polylineLimit   = 10000
    size            = int(array.size(averagePoints)/polylineLimit)
    for index = 0 to size
        if showPriceInput
            polyline.new(array.slice(chartPoints,math.min(0,index*polylineLimit),math.min(array.size(chartPoints),index*polylineLimit+polylineLimit)),priceCurvedInput,line_color = priceColorInput,line_width = linesWidthInput)            

        if showAverageInput
            polyline.new(array.slice(averagePoints,math.min(0,index*polylineLimit),math.min(array.size(averagePoints),index*polylineLimit+polylineLimit)),averageCurvedInput,line_color = averageColorInput,line_width = linesWidthInput)
           
    // we plot price tags and spirals for each price level
    if showPriceScaleInput
        offset =  0.5 * math.pi
        for [index,element] in array.from(10,100,1000,10000,100000,1000000)

            data        = math.log10(element)

            tag1Point   = spiralPoint(data,0-math.pi/8+offset,spiralAnchor,spiralScale)
            tag2Point   = spiralPoint(data,0+math.pi/8+offset,spiralAnchor,spiralScale)            
            tag3Point   = spiralPoint(data,math.pi-math.pi/8+offset,spiralAnchor,spiralScale)                        
            tag4Point   = spiralPoint(data,math.pi+math.pi/8+offset,spiralAnchor,spiralScale)
            
            array<chart.point> points = array.new<chart.point>()    

            for priceIndex = 0 to barsPerCyleInput
                theta = priceIndex * step
                points.push(spiralPoint(data,theta,spiralAnchor,spiralScale))

            label.new(point = tag1Point,text = str.format('{0,number,currency}',element),textcolor = priceScaleColorInput,color = color(na),style = label.style_label_left,size = textSizeInput)
            label.new(point = tag2Point,text = str.format('{0,number,currency}',element),textcolor = priceScaleColorInput,color = color(na),style = label.style_label_left,size = textSizeInput)
            label.new(point = tag3Point,text = str.format('{0,number,currency}',element),textcolor = priceScaleColorInput,color = color(na),style = label.style_label_right,size = textSizeInput)
            label.new(point = tag4Point,text = str.format('{0,number,currency}',element),textcolor = priceScaleColorInput,color = color(na),style = label.style_label_right,size = textSizeInput)
            
            polyline.new(points,curved = true,closed = true, line_color = priceColorInput,line_width = 1, line_style = line.style_dashed)

    // we plot the clock handle as a line
    if showClockHandleInput and chartPoints.size() > 0
        line.new(chartPoints.first(),chartPoints.last(),color=clockHandleColorInput,width = 4)

    // we plot clock hours (3, 6, 9 & 12) as tables
    if showHoursInput
        plotTable(position.top_center,      '12\nTop of cycle',                     color.new(color.red,    25))
        plotTable(position.middle_right,    '3\nBottom of cycle',                   color.new(color.green,  25))
        plotTable(position.bottom_center,   '6\nTransition\nfrom bear to bull',     color.new(color.yellow, 25))
        plotTable(position.middle_left,     '9\nTransition\nto frenzy bull market', color.new(color.blue,   25))

    // we plot halvings as circle labels
    if showHalvingsInput
        for [index,spiralDate] in spiralDates
            if halvings.includes(spiralDate)
                label.new(point = chartPoints.get(index),color = halvingsColorInput, style = label.style_circle,size = textSizeInput)

//---------------------------------------------------------------------------------------------------------------------}
//MUTABLE VARIABLES & EXECUTION
//---------------------------------------------------------------------------------------------------------------------{
// we update current visible chart boundaries for anchor calculations
left_visible_bar_index  := time == chart.left_visible_bar_time  ? bar_index : left_visible_bar_index
right_visible_bar_index := time == chart.right_visible_bar_time ? bar_index : right_visible_bar_index

// we gather data into storage
source  = math.log10(close)
bars.push(bar.new(close,time))
array.push(dataPoints,source)

// we calculate average
secondPass := filtfilt(source, barsPerCyleInput/4)

// we execute only once at end of historical time serie
if barstate.islastconfirmedhistory    
    plotSpiral()    

//Display dashboard
if barstate.islast and showDashboardInput
    tb.cell(0, 0, 'Bitcoin Power Law\nTime & Price'
      , text_color  = color.white
      , text_size   = table_size)

    txt = str.format('Time : {0} \n\n Price : ${1}', clockTime.tag, str.tostring(math.round_to_mintick(close)))

    tb.cell(0, 1, txt
      , text_color  = color.white
      , text_size   = table_size
      , text_halign = text.align_left)

//---------------------------------------------------------------------------------------------------------------------}    