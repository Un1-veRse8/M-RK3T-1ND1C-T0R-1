// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tkarolak

//@version=5
// @description Utilizes k-NN machine learning to predict breakout zones from pivot points, aiding traders in identifying potential bullish and bearish market movements. Ideal for trend-following and breakout strategies.
library("MLPivotsBreakouts", true)

// @type Defines a data structure for storing pivot points.
// @field price array - An array of pivot prices.
// @field index array - An array of bar indexes corresponding to the pivot points.
type Pivots
	array<float> price
	array<int> index

// @function Updates Pivots with new data, maintaining a maxData limit.
// @param d Pivots: The Pivots data structure to update.
// @param price float: The price of the new pivot point.
// @param index int: The index of the new pivot point.
// @param maxData int: Maximum number of data points to store.
// @returns void
method storeData(Pivots d, float price, int index, int maxData) =>
	d.price.push(price)
	d.index.push(index)
	if array.size(d.price) > maxData
		array.shift(d.price)
		array.shift(d.index)

// @function Predicts future pivot points using k-NN algorithm.
// @param d Pivots: The Pivots data structure for prediction.
// @param currentPrice float: Current price for distance calculation.
// @param k int: Number of neighbors to consider for prediction.
// @returns float: Predicted pivot price based on nearest neighbors.
method knnPredict(Pivots d, float currentPrice, int k) =>
	distances = array.new_float()
	for i = 0 to array.size(d.price) - 1
		distance = math.sqrt(math.pow(currentPrice - d.price.get(i), 2) + math.pow(bar_index - d.index.get(i), 2))
		array.push(distances, distance)
	sortedIndices = array.sort_indices(distances)
	neighbors = array.new_float()
	for i = 0 to k - 1
		array.push(neighbors, d.price.get(sortedIndices.get(i)))
	prediction = array.avg(neighbors)

// @function Detects and predicts breakout points from pivot data.
// @param pivotBars int: Number of bars for pivot point detection.
// @param numNeighbors int: Neighbors count for k-NN prediction.
// @param maxData int: Maximum pivot data points for analysis.
// @param predictionSmoothing int: Smoothing period for predictions.
// @returns [series float, series float, series int]: Lower and higher prediction bands plus pivot signal, 1 for ph and -1 for pl.
export breakouts(int pivotBars = 20, int numNeighbors = 20, int maxData = 800, int predictionSmoothing = 20) =>
	var pivotLows = Pivots.new(array.new_float(numNeighbors,na), array.new_int(numNeighbors,na))
	var pivotHighs = Pivots.new(array.new_float(numNeighbors,na), array.new_int(numNeighbors,na))
	// Detecting pivot points
	pivotHigh = ta.pivothigh(pivotBars, pivotBars)
	pivotLow = ta.pivotlow(pivotBars, pivotBars)
	phDetected = not na(pivotHigh)
	plDetected = not na(pivotLow)
	// Store pivot points
	if phDetected
		pivotHighs.storeData(high[pivotBars], bar_index[pivotBars], maxData)
	if plDetected
		pivotLows.storeData(low[pivotBars], bar_index[pivotBars], maxData)
	// Perform predictions
	lowExtrapolated = knnPredict(pivotLows, low, numNeighbors)
	highExtrapolated = knnPredict(pivotHighs, high, numNeighbors)
	// Apply smoothing to predictions
	lowerBand = ta.wma(lowExtrapolated, predictionSmoothing)
	higherBand = ta.wma(highExtrapolated, predictionSmoothing)
	[lowerBand, higherBand, phDetected ? 1 : plDetected ? -1 : na]