// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © RWCS_LTD

//@version=6
indicator("Adaptive Multi-MA Optimizer", overlay=true, max_bars_back=500)

// === USER SETTINGS ===
maOptions = input.string("Composite", title="MA Type", options=["SMA", "EMA", "WMA", "VWMA", "DEMA", "TEMA", "Hull", "ALMA", "Composite"])
minLen     = input.int(5,  "Minimum Lookback", minval=1, maxval=100)
maxLen     = input.int(50, "Maximum Lookback", minval=2, maxval=500)
step       = input.int(2,  "Optimization Step", minval=1, maxval=50)
source     = input.source(close, "Source")

// === RETURN CALCULATION ===
ret = (source / source[1]) - 1

// === CUSTOM MA FUNCTIONS ===
custom_sma(src, len) =>
    float result = na
    if bar_index >= len
        sum = 0.0
        for i = 0 to len - 1
            sum += src[i]
        result := sum / len
    result

custom_ema(src, len) =>
    alpha = 2.0 / (len + 1)
    ema = 0.0
    ema := na(ema[1]) ? src : (src * alpha + ema[1] * (1 - alpha))
    ema

custom_wma(src, len) =>
    float result = na
    if bar_index >= len
        weight = 0.0
        sum = 0.0
        for i = 0 to len - 1
            weight := weight + (len - i)
            sum := sum + src[i] * (len - i)
        result := sum / weight
    result

custom_vwma(src, len) =>
    vwma = 0.0
    if bar_index >= len
        sumPV = 0.0
        sumVol = 0.0
        for i = 0 to len - 1
            sumPV += (src[i] * volume[i])
            sumVol += volume[i]
        vwma := sumVol != 0 ? sumPV / sumVol : na
    vwma

custom_dema(src, len) =>
    ema1 = custom_ema(src, len)
    ema2 = custom_ema(ema1, len)
    2 * ema1 - ema2

custom_tema(src, len) =>
    ema1 = custom_ema(src, len)
    ema2 = custom_ema(ema1, len)
    ema3 = custom_ema(ema2, len)
    3 * (ema1 - ema2) + ema3

custom_hull(src, len) =>
    half = math.floor(len / 2)
    sqrtlen = math.round(math.sqrt(len))
    wma_half = custom_wma(src, half)
    wma_full = custom_wma(src, len)
    diff = 2 * wma_half - wma_full
    custom_wma(diff, sqrtlen)

custom_alma(src, len, offset=0.85, sigma=6.0) =>
    m = math.floor(offset * (len - 1))
    s = len > 1 ? len / sigma : 1
    sum = 0.0
    norm = 0.0
    for i = 0 to len - 1
        weight = math.exp(-math.pow(i - m, 2) / (2 * s * s))
        sum += src[i] * weight
        norm += weight
    sum / norm

// === ALL MA CALCULATIONS ===
smaVal = custom_sma(source, maxLen)
emaVal = custom_ema(source, maxLen)
wmaVal = custom_wma(source, maxLen)
vwmaVal = custom_vwma(source, maxLen)
demaVal = custom_dema(source, maxLen)
temaVal = custom_tema(source, maxLen)
hullVal = custom_hull(source, maxLen)
almaVal = custom_alma(source, maxLen)

// === COMPOSITE MA ===
composite_ma(src, len) =>
    avg = (
         custom_sma(src, len) +
         custom_ema(src, len) +
         custom_wma(src, len) +
         custom_vwma(src, len) +
         custom_dema(src, len) +
         custom_tema(src, len) +
         custom_hull(src, len) +
         custom_alma(src, len)
         ) / 8
    avg

// === MA SELECTOR ===
custom_ma(src, len, maType) =>
     maType == "EMA"     ? custom_ema(src, len) :
     maType == "WMA"     ? custom_wma(src, len) :
     maType == "VWMA"    ? custom_vwma(src, len) :
     maType == "DEMA"    ? custom_dema(src, len) :
     maType == "TEMA"    ? custom_tema(src, len) :
     maType == "HullMA"  ? custom_hull(src, len) :
     maType == "ALMA"    ? custom_alma(src, len) :
     maType == "Composite" ? composite_ma(src, len) :
     custom_sma(src, len)

// === CUSTOM STDEV ===
custom_stdev(src, len) =>
    float result = na
    if bar_index >= len
        mean = custom_sma(src, len)
        sumSq = 0.0
        for i = 0 to len - 1
            sumSq += math.pow(src[i] - mean, 2)
        result := math.sqrt(sumSq / len)
    result

// === OPTIMIZATION LOGIC ===
int bestLen = minLen
float bestStability = 999.0
float selectedMA = na

if bar_index >= (maxLen + step)
    for len = minLen to maxLen by step
        stdNow = custom_stdev(ret, len)
        stdPrev = custom_stdev(ret, len - step)
        if not na(stdNow) and not na(stdPrev)
            diff = math.abs(stdNow - stdPrev)
            if diff < bestStability
                bestStability := diff
                bestLen := len
                selectedMA := custom_ma(source, bestLen, maOptions)

// === DYNAMIC SMOOTHING ===
smoothLen = math.max(2, math.floor(bestLen / 2))  // Avoid too short lengths
smoothedComposite = custom_ema(composite_ma(source, bestLen), smoothLen)

maVal = custom_ma(source, bestLen, maOptions)

// === PLOTTING ===
plot(
     maOptions == "Composite" ? smoothedComposite : maVal,
     title="Adaptive MA",
     color=(maOptions == "Composite" ? smoothedComposite : maVal) < source ? color.aqua : color.fuchsia,
     linewidth=2
     )
