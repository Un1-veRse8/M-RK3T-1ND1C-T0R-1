// This Pine Script‚Ñ¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Editor: ¬© BarefootJoey
// Author: ¬© LonesomeTheBlue

//@version=5
indicator("SemiCircle Cycle Notation Pivots", max_bars_back = 500, max_lines_count = 500, overlay=false)

// Input Parameters
pivot_type = input.string("Both", "Pivot Type", options=["High Only", "Low Only", "Both"], group="General Settings")

// Cycle Lengths üìè
prd1 = input.int(defval = 10, title="1", group="Lengths")
prd2 = input.int(defval = 20, title="2", group="Lengths")
prd3 = input.int(defval = 40, title="3", group="Lengths")

// Visual Settings üé®
col1 = input.color(color.green, title='1', group="Colors")
col2 = input.color(color.yellow, title='2', group="Colors")
col3 = input.color(color.orange, title='3', group="Colors")

// Calculate highest and lowest points for each period
phs = array.from(
 (pivot_type != "Low Only") and ta.highestbars(high, prd1) == 0 ? high : na,
 (pivot_type != "Low Only") and ta.highestbars(high, prd2) == 0 ? high : na,
 (pivot_type != "Low Only") and ta.highestbars(high, prd3) == 0 ? high : na) 
pls = array.from(
 (pivot_type != "High Only") and ta.lowestbars(low, prd1) == 0 ? low : na,
 (pivot_type != "High Only") and ta.lowestbars(low, prd2) == 0 ? low : na,
 (pivot_type != "High Only") and ta.lowestbars(low, prd3) == 0 ? low : na) 
 
// Initialize and calculate zigzag direction
var dirs = array.new_int(4, pivot_type == "Low Only" ? -1 : 1)
olddirs = array.copy(dirs)
for x = 0 to 2
    array.set(dirs, x, 
             pivot_type == "High Only" ? (array.get(phs, x) ? -1 : 1) :
             pivot_type == "Low Only" ? (array.get(pls, x) ? 1 : -1) :
             (array.get(phs, x) and na(array.get(pls, x))) ? 1 : 
             (array.get(pls, x) and na(array.get(phs, x))) ? -1 : 
             array.get(dirs, x))

// ZigZag Configuration
var max_array_size = 6
var zigzag1 = array.new_float(0)
var zigzag2 = array.new_float(0)
var zigzag3 = array.new_float(0)

// Add new point to zigzag sequence
add_to_zigzag(zigzag, value)=>
    array.unshift(zigzag, bar_index)
    array.unshift(zigzag, value)
    if array.size(zigzag) > max_array_size
        array.pop(zigzag)
        array.pop(zigzag)

// Update zigzag level on same direction movement
update_zigzag(zigzag, dir, value)=>
    if array.size(zigzag) == 0
        add_to_zigzag(zigzag, value)
    else
        if (dir == 1 and value > array.get(zigzag, 0)) or (dir == -1 and value < array.get(zigzag, 0))
            array.set(zigzag, 0, value)
            array.set(zigzag, 1, bar_index)
        0.

// Calculate zigzag patterns based on pivot type
CalculateZigzag(zigzag, dir, ph, pl, dirchanged)=>
    if pivot_type == "High Only" and ph
        if dirchanged or array.size(zigzag) == 0
            add_to_zigzag(zigzag, ph)
        else
            update_zigzag(zigzag, 1, ph)
    else if pivot_type == "Low Only" and pl
        if dirchanged or array.size(zigzag) == 0
            add_to_zigzag(zigzag, pl)
        else
            update_zigzag(zigzag, -1, pl)
    else if pivot_type == "Both" and (ph or pl)
        if dirchanged
            add_to_zigzag(zigzag, dir == 1 ? ph : pl)
        else
            update_zigzag(zigzag, dir, dir == 1 ? ph : pl)

// Apply zigzag calculations for each period
CalculateZigzag(zigzag1, array.get(dirs, 0), array.get(phs, 0), array.get(pls, 0), array.get(dirs, 0) != array.get(olddirs, 0))
CalculateZigzag(zigzag2, array.get(dirs, 1), array.get(phs, 1), array.get(pls, 1), array.get(dirs, 1) != array.get(olddirs, 1))
CalculateZigzag(zigzag3, array.get(dirs, 2), array.get(phs, 2), array.get(pls, 2), array.get(dirs, 2) != array.get(olddirs, 2))

// Wave Length Tracking
var int [] totallength = array.from(0, 0, 0)
var int [] totalchange = array.from(0, 0, 0)
int [] cyclelen = array.from(0, 0, 0)
var cycleAnddir = array.from(-1000, 1, -1000, 1, -1000, 1)

// Initialize offset variables in global scope
var int offset1 = 0
var int offset2 = 0
var int offset3 = 0

// Process wave calculations for each period
for x = 0 to 2
    float [] zigzag = x == 0 ? zigzag1 : x == 1 ? zigzag2 : zigzag3

    if array.get(dirs, x) != array.get(olddirs, x) and array.size(zigzag) >= max_array_size
        array.set(totallength, x, array.get(totallength, x) + math.round(array.get(zigzag, 3) - array.get(zigzag, 5)) + 1)
        array.set(totalchange, x, array.get(totalchange, x) + 1)
        
    // Calculate cycle length with pivot type adjustment
    multiplier = pivot_type == "Both" ? 2 : 1
    array.set(cyclelen, x, math.round(array.get(totallength, x) / (math.max(array.get(totalchange, x), 1) * multiplier)))
    
    // Initialize and update cycle direction
    min_changes = pivot_type == "Both" ? 10 : 3
    if array.get(cycleAnddir, x * 2) == -1000 and 
       array.get(totalchange, x) > min_changes and 
       (array.get(dirs, x) != array.get(olddirs, x) or array.size(zigzag) == 0)
        array.set(cycleAnddir, x * 2, array.get(dirs, x) * math.round(bar_index - array.get(zigzag, 3)))
        array.set(cycleAnddir, x * 2 + 1, array.get(dirs, x)) 
    else if array.get(cycleAnddir, x * 2) > -1000
        array.set(cycleAnddir, x * 2, array.get(cycleAnddir, x * 2) + array.get(cycleAnddir, x * 2 + 1))
        if array.get(cycleAnddir, x * 2) < -array.get(cyclelen, x) or array.get(cycleAnddir, x * 2) > array.get(cyclelen, x)
            array.set(cycleAnddir, x * 2 + 1, -1 * array.get(cycleAnddir, x * 2 + 1))
            array.set(cycleAnddir, x * 2, array.get(cycleAnddir, x * 2) + 2 * array.get(cycleAnddir, x * 2 + 1))
            if array.get(cycleAnddir, x * 2) > array.get(cyclelen, x)
                array.set(cycleAnddir, x * 2, array.get(cyclelen, x) - 1)
            else if array.get(cycleAnddir, x * 2) < -array.get(cyclelen, x)
                array.set(cycleAnddir, x * 2, -array.get(cyclelen, x) + 1)

// Calculate offsets based on half of actual cycle lengths after the loop
offset1 := math.round(array.get(cyclelen, 0) / 2) + prd1
offset2 := math.round(array.get(cyclelen, 1) / 2) + prd2
offset3 := math.round(array.get(cyclelen, 2) / 2) + prd3

// Wave Calculations üåä
wave_multiplier = pivot_type == "Both" ? 1.0 : 1.0

// Calculate base waves using semicircle mathematics
float wave1 = array.get(cyclelen, 0) > 0 and not na(array.get(cycleAnddir, 0)) ? wave_multiplier * math.sign(array.get(cycleAnddir, 0)) * math.sqrt(math.pow(array.get(cyclelen, 0), 2) - math.pow(array.get(cyclelen, 0) - math.abs(array.get(cycleAnddir, 0)), 2)) : 0
float wave2 = array.get(cyclelen, 1) > 0 and not na(array.get(cycleAnddir, 2)) ? wave_multiplier * math.sign(array.get(cycleAnddir, 2)) * math.sqrt(math.pow(array.get(cyclelen, 1), 2) - math.pow(array.get(cyclelen, 1) - math.abs(array.get(cycleAnddir, 2)), 2)) : 0
float wave3 = array.get(cyclelen, 2) > 0 and not na(array.get(cycleAnddir, 4)) ? wave_multiplier * math.sign(array.get(cycleAnddir, 4)) * math.sqrt(math.pow(array.get(cyclelen, 2), 2) - math.pow(array.get(cyclelen, 2) - math.abs(array.get(cycleAnddir, 4)), 2)) : 0

// Adjust wave values based on pivot type
plot_wave1 = pivot_type == "High Only" ? math.abs(wave1) : pivot_type == "Low Only" ? -1 * math.abs(wave1) : wave1
plot_wave2 = pivot_type == "High Only" ? math.abs(wave2) : pivot_type == "Low Only" ? -1 * math.abs(wave2) : wave2
plot_wave3 = pivot_type == "High Only" ? math.abs(wave3) : pivot_type == "Low Only" ? -1 * math.abs(wave3) : wave3

// Render waves with dynamic offsets based on actual cycle lengths
plot(plot_wave3, "40", color = col3, style = plot.style_line, offset=offset3)
plot(plot_wave2, "20", color = col2, style = plot.style_line, offset=offset2)
plot(plot_wave1, "10", color = col1, style = plot.style_line, offset=offset1)

// Made with ‚ù§ by @BarefootJoey ‚úåüíóüìà
